# ISSUE: Dictionary Key Corruption in Dynamic Configuration Filler

**Date:** 2026-01-16  
**Author:** Dario Airoldi  
**Status:** Resolved  
**Severity:** High  
**Component:** Diginsight.Diagnostics  
**Target Framework:** netstandard2.0+, .NET 8+  

---

## ğŸ“‹ Table of Contents

1. [ğŸ“ Description](#-description)
2. [ğŸ” Context Information](#-context-information)
3. [ğŸ”¬ Analysis](#-analysis)
4. [ğŸ”„ Reproduction Steps](#-reproduction-steps)
5. [âœ… Solution Implemented](#-solution-implemented)
6. [ğŸ“š Additional Information](#-additional-information)
7. [âœ”ï¸ Resolution Status](#ï¸-resolution-status)
8. [ğŸ“ Lessons Learned](#-lessons-learned)
9. [ğŸ“ Appendix](#-appendix)

---

## ğŸ“ DESCRIPTION

Dictionary properties in `DiginsightActivitiesOptions` (specifically `LoggedActivityNames`) become corrupted when dynamic configuration is applied via HTTP headers, even when the dictionary itself is NOT included in the headers.

### Error Message
```
Dictionary keys become malformed:
Expected: "SmartCache.SetValue"
Actual:   "[SmartCache.SetValue,"

The key includes bracket and comma characters from KeyValuePair.ToString() format.
```

### Impact
- âŒ Activity filtering by `LoggedActivityNames` fails completely
- âŒ Log entries that should be hidden/truncated appear incorrectly
- âŒ Configuration loaded from appsettings.json gets corrupted on first request with any Dynamic-Configuration header
- âš ï¸ Affects all users who configure `LoggedActivityNames` in appsettings.json and use dynamic configuration for other options

---

## ğŸ” CONTEXT INFORMATION

### Environment Details
- **Project:** Diginsight.Diagnostics
- **Target Framework:** netstandard2.0, netstandard2.1, net6.0, net7.0, net8.0
- **Configuration Source:** appsettings.json + HTTP headers (Dynamic-Configuration)
- **Affected Classes:** `DiginsightActivitiesOptions`, `DynamicallyConfigureClassAwareOptions`

### Exception Details
| Property | Value |
|----------|-------|
| **Issue Type** | Data Corruption |
| **Trigger** | HTTP request with `Dynamic-Configuration` header |
| **Affected Property** | `LoggedActivityNames` dictionary |

### Configuration Example (appsettings.json)
```json
{
  "Diginsight": {
    "Activities": {
      "LoggedActivityNames": {
        "System.Net.Http|System.Net.Http.HttpRequestOut": "Hide",
        "Microsoft.AspNetCore.Hosting.HttpRequestIn": "Hide",
        "SmartCache.OnEvicted": "Hide",
        "SmartCache.SetValue": "Hide",
        "SmartCache.Invalidate": "Hide",
        "ServiceBusReceiver.Complete": "Hide",
        "ServiceBusReceiver.Receive": "Truncate",
        "ServiceBusProcessor.ProcessMessage": "Truncate"
      }
    }
  }
}
```

### HTTP Header Example
```
Dynamic-Configuration: PermissionCheckEnabled=false MaxAge=0
```

Note: The header does NOT contain `LoggedActivityNames`, yet the dictionary becomes corrupted.

### Variable Values at Exception Time
```csharp
// BEFORE Dynamic Configuration binding:
LoggedActivityNames = {
    {"SmartCache.SetValue", Show},
    {"SmartCache.OnEvicted", Show},
    {"SmartCache.Invalidate", Show}
    // ... etc
}

// AFTER Dynamic Configuration binding (CORRUPTED):
LoggedActivityNames = {
    {"[SmartCache.SetValue,", Show},
    {"[SmartCache.OnEvicted,", Show},
    {"[SmartCache.Invalidate,", Show}
    // ... etc
}
```

---

## ğŸ”¬ ANALYSIS

### Root Cause Analysis

#### 1. The Filler Pattern for Dictionary-to-String Conversion
`DiginsightActivitiesOptions` implements `IDynamicallyConfigurable` and uses a `Filler` class to convert dictionary properties to/from strings for HTTP header binding.

The `LoggedActivityNames` property on `Filler` has:
- **Getter**: Serializes dictionary to string
- **Setter**: Parses string back to dictionary

#### 2. The Bug in the Getter
```csharp
// BUGGY CODE:
get => string.Join(" ", filled.LoggedActivityNames);

// This implicitly calls KeyValuePair<string, LogBehavior>.ToString()
// which produces: "[Key, Value]" format
// 
// Result: "[SmartCache.SetValue, Show] [SmartCache.OnEvicted, Hide] ..."
```

#### 3. The Configuration Binding Behavior
When `configuration.Bind(options.MakeFiller())` is called:
1. The binder enumerates all properties on `Filler`
2. For the `LoggedActivityNames` string property, it calls the **getter** first
3. The getter produces malformed output: `"[SmartCache.SetValue, Show] [SmartCache.OnEvicted, Hide]"`
4. In certain scenarios (possibly FilteredConfiguration wrapping), this value gets passed back to the **setter**
5. The setter parses on space and `=`, producing keys like `"[SmartCache.SetValue,"` and values parsed from remaining fragments

#### Error Manifestation Flow
```
1. Request arrives with Dynamic-Configuration: PermissionCheckEnabled=false
2. DynamicallyConfigureClassAwareOptions.Configure() is called
3. ConfigureCore() builds in-memory config from header (only PermissionCheckEnabled)
4. configuration.Bind(options.MakeFiller()) is invoked
5. Binder calls Filler.LoggedActivityNames getter â†’ "[SmartCache.SetValue, Show] ..."
6. Due to binding behavior + FilteredConfiguration, setter is invoked with getter output
7. Setter parses: "[SmartCache.SetValue," becomes a dictionary key
8. Original dictionary data is lost/corrupted
```

### Impact Assessment

| Category | Impact | Severity |
|----------|--------|----------|
| **Functionality** | Activity log filtering completely broken | High |
| **Data Integrity** | Configuration data corrupted per-request | High |
| **User Experience** | Wrong activities shown/hidden in logs | Medium |

### Affected Workflows
1. âŒ **Activity Log Filtering**: `LoggedActivityNames` dictionary lookup fails for all entries
2. âŒ **Dynamic Configuration**: Any use of Dynamic-Configuration header triggers corruption
3. âŒ **Log Analysis**: Developers see unexpected activity entries in output
4. âœ… **Static Configuration Only**: Works correctly when no Dynamic-Configuration headers used

---

## ğŸ”„ REPRODUCTION STEPS

### Step-by-Step Reproduction
1. **Configure LoggedActivityNames in appsettings.json**:
   ```json
   {
     "Diginsight": {
       "Activities": {
         "LoggedActivityNames": {
           "SmartCache.SetValue": "Hide",
           "SmartCache.OnEvicted": "Hide"
         }
       }
     }
   }
   ```

2. **Register dynamic configuration in Startup**:
   ```csharp
   services.ConfigureClassAware<DiginsightActivitiesOptions>(configuration.GetSection("Diginsight:Activities"))
       .DynamicallyConfigureClassAware<DiginsightActivitiesOptions>();
   ```

3. **Send HTTP request with any Dynamic-Configuration header**:
   ```http
   GET /api/weather HTTP/1.1
   Dynamic-Configuration: MaxAge=0
   ```

4. **Dictionary corruption occurs**: Inspect `LoggedActivityNames` in debugger - keys now contain `[` and `,` characters

### Affected Code Location
**File:** `src/Diginsight.Diagnostics/DiginsightActivitiesOptions.cs`  
**Class:** `DiginsightActivitiesOptions.Filler`  
**Property:** `LoggedActivityNames`  
**Line:** 178 (original)

```csharp
// PROBLEMATIC CODE (line 178):
get => string.Join(" ", filled.LoggedActivityNames);

// This calls KeyValuePair.ToString() implicitly, producing "[Key, Value]" format
```

---

## âœ… SOLUTION IMPLEMENTED

### Fix Overview
Two changes were implemented to resolve the issue:

1. **Fix the getter serialization** - Properly format `KeyValuePair` as `key=value` instead of relying on `ToString()`
2. **Add setter guard** - Skip dictionary modification if the incoming value matches the current serialized form (prevents unnecessary round-trip corruption)

### Code Changes

#### 1. Fix Getter Serialization
**Location:** `src/Diginsight.Diagnostics/DiginsightActivitiesOptions.cs` (line 178)

```csharp
// BEFORE (BUGGY):
get => string.Join(" ", filled.LoggedActivityNames);

// AFTER (FIXED):
get => string.Join(" ", filled.LoggedActivityNames.Select(static kv => $"{kv.Key}={kv.Value}"));
```

#### 2. Add Setter Guard
**Location:** `src/Diginsight.Diagnostics/DiginsightActivitiesOptions.cs` (setter)

```csharp
// BEFORE:
set
{
    filled.LoggedActivityNames.Clear();
    filled.LoggedActivityNames.AddRange(/* parsing logic */);
}

// AFTER:
set
{
    // Skip if value matches current serialized form (avoids unnecessary clear/repopulate)
    if (value == string.Join(" ", filled.LoggedActivityNames.Select(static kv => $"{kv.Key}={kv.Value}")))
        return;

    filled.LoggedActivityNames.Clear();
    filled.LoggedActivityNames.AddRange(/* parsing logic */);
}
```

### Solution Features

#### âœ… Correct Serialization Format
- Keys serialized as `SmartCache.SetValue=Show` instead of `[SmartCache.SetValue, Show]`
- Round-trip parsing now works correctly

#### âœ… Idempotent Setter
- If setter receives the same value as current state, dictionary is not modified
- Prevents corruption from binding behavior that reads getter then calls setter

### Transformation Examples

| Input Dictionary | Getter Output (Before) | Getter Output (After) |
|------------------|------------------------|------------------------|
| `{"SmartCache.SetValue": Show}` | `[SmartCache.SetValue, Show]` | `SmartCache.SetValue=Show` |
| `{"A": Hide, "B": Show}` | `[A, Hide] [B, Show]` | `A=Hide B=Show` |

---

## ğŸ“š ADDITIONAL INFORMATION

### Testing Recommendations

#### Unit Tests
```csharp
[TestFixture]
public class DiginsightActivitiesOptionsFillerTests
{
    [Test]
    public void LoggedActivityNames_RoundTrip_PreservesKeys()
    {
        // Arrange
        var options = new DiginsightActivitiesOptions();
        options.LoggedActivityNames["SmartCache.SetValue"] = LogBehavior.Hide;
        options.LoggedActivityNames["SmartCache.OnEvicted"] = LogBehavior.Show;
        
        var filler = (object)options.MakeFiller();
        var prop = filler.GetType().GetProperty("LoggedActivityNames");
        
        // Act - simulate round-trip
        var serialized = (string)prop.GetValue(filler);
        prop.SetValue(filler, serialized);
        
        // Assert
        Assert.That(options.LoggedActivityNames.ContainsKey("SmartCache.SetValue"), Is.True);
        Assert.That(options.LoggedActivityNames["SmartCache.SetValue"], Is.EqualTo(LogBehavior.Hide));
    }

    [Test]
    public void LoggedActivityNames_Setter_SkipsWhenUnchanged()
    {
        // Arrange
        var options = new DiginsightActivitiesOptions();
        options.LoggedActivityNames["Test"] = LogBehavior.Show;
        var originalDict = options.LoggedActivityNames;
        
        var filler = (object)options.MakeFiller();
        var prop = filler.GetType().GetProperty("LoggedActivityNames");
        
        // Act - set with same value
        var serialized = (string)prop.GetValue(filler);
        prop.SetValue(filler, serialized);
        
        // Assert - dictionary instance should be same (not cleared/repopulated)
        Assert.That(options.LoggedActivityNames, Is.SameAs(originalDict));
    }
}
```

#### Integration Tests
1. **Dynamic Configuration with unrelated headers**
   - Send request with `Dynamic-Configuration: MaxAge=0`
   - Verify `LoggedActivityNames` dictionary is unchanged
   - Expected: All keys remain valid

2. **Dynamic Configuration with LoggedActivityNames override**
   - Send request with `Dynamic-Configuration: LoggedActivityNames=Test=Hide`
   - Verify dictionary is correctly updated
   - Expected: Dictionary contains `{"Test": Hide}`

### Migration Considerations

#### âš ï¸ Important: Existing Configurations
This fix changes the serialization format but maintains backward compatibility:

| Format | Getter Output | Setter Parsing |
|--------|---------------|----------------|
| Old (buggy) | `[Key, Value]` | Would produce corrupted keys |
| New (fixed) | `Key=Value` | Parses correctly |

The setter already expected `Key=Value` format, so no migration is needed for existing HTTP header configurations.

### Performance Impact

| Operation | Before Fix | After Fix | Delta |
|-----------|------------|-----------|-------|
| **Getter Serialization** | O(n) implicit ToString() | O(n) explicit format | ~Same |
| **Setter with unchanged value** | O(n) clear + parse | O(n) compare + early return | Better (no allocation) |
| **Setter with changed value** | O(n) clear + parse | O(n) compare + O(n) parse | Slightly slower (extra compare) |

The performance impact is negligible since dictionary sizes are typically small (10-50 entries).

---

## ğŸ“ REFERENCES

### Code References

#### Modified Files
| File | Path | Changes |
|------|------|---------|
| **DiginsightActivitiesOptions.cs** | `src/Diginsight.Diagnostics/` | Fixed Filler.LoggedActivityNames getter and setter |

#### Modified Methods
- `Filler.LoggedActivityNames` getter - Changed from implicit `ToString()` to explicit `$"{kv.Key}={kv.Value}"` format
- `Filler.LoggedActivityNames` setter - Added guard to skip processing when value unchanged

### Related Classes
- `DynamicallyConfigureOptions` - Calls `configuration.Bind(options.MakeFiller())`
- `DynamicallyConfigureClassAwareOptions` - Wraps configuration in `FilteredConfiguration`
- `FilteredConfiguration` - May contribute to binding behavior that triggers the round-trip

---

## âœ”ï¸ RESOLUTION STATUS

### ğŸ¯ **STATUS: RESOLVED**

**Resolution Date:** 2026-01-16  
**Resolved By:** GitHub Copilot + Dario Airoldi  
**Resolution Type:** Code Fix  

### Verification Checklist

- [x] **Code Changes Implemented**
  - [x] Fixed getter serialization format
  - [x] Added setter guard for unchanged values

- [ ] **Testing** 
  - [ ] Unit tests created/updated
  - [ ] Integration tests passed
  - [ ] End-to-end tests verified

- [ ] **Deployment**
  - [ ] Deployed to development environment
  - [ ] Deployed to staging environment
  - [ ] Deployed to production environment

### Follow-up Actions

#### Immediate (Priority 1)
- [ ] Test fix with original reproduction scenario
- [ ] Verify LoggedActivityNames filtering works correctly

#### Short-term (Priority 2)
- [ ] Add unit tests for Filler round-trip serialization
- [ ] Check for similar issues in other Filler properties (e.g., `ActivitySources`)

#### Long-term (Priority 3)
- [ ] Consider creating a base class or helper for Filler dictionary serialization
- [ ] Document the expected format for dictionary properties in Dynamic-Configuration headers

---

## ğŸ“ LESSONS LEARNED

### What Went Wrong
1. **Implicit ToString() reliance**: Using `string.Join()` on a dictionary implicitly calls `KeyValuePair.ToString()` which produces `[Key, Value]` format - not suitable for parsing
2. **No round-trip testing**: The Filler getter/setter pair was not tested for round-trip consistency
3. **Binding behavior assumption**: Assumed the setter would only be called when the configuration explicitly contains the key

### What Went Right
1. **Systematic debugging**: Traced the issue from symptoms (corrupted keys) to root cause (getter format)
2. **Minimal fix**: Solution addresses root cause without major architectural changes
3. **Defensive coding**: Added setter guard to prevent future similar issues

### Improvements for Future
1. **Test round-trip serialization**: All Filler properties that convert between complex types and strings should have round-trip tests
2. **Explicit serialization**: Never rely on implicit `ToString()` for serialization - always use explicit formatting
3. **Document Filler pattern**: Add documentation about the Filler pattern and its requirements for proper getter/setter implementation

---

## ğŸ“ APPENDIX

### A. Full Filler Class (After Fix)

```csharp
private class Filler
{
#if NET || NETSTANDARD2_1_OR_GREATER
    private const char SpaceSeparator = ' ';
    private const char EqualsSeparator = '=';
#else
    private static readonly char[] SpaceSeparator = [ ' ' ];
    private static readonly char[] EqualsSeparator = [ '=' ];
#endif

    private readonly DiginsightActivitiesOptions filled;

    public string LoggedActivityNames
    {
        get => string.Join(" ", filled.LoggedActivityNames.Select(static kv => $"{kv.Key}={kv.Value}"));
        set
        {
            // Skip if value matches current serialized form (avoids unnecessary clear/repopulate)
            if (value == string.Join(" ", filled.LoggedActivityNames.Select(static kv => $"{kv.Key}={kv.Value}")))
                return;

            filled.LoggedActivityNames.Clear();
            filled.LoggedActivityNames.AddRange(
                value.Split(SpaceSeparator, StringSplitOptions.RemoveEmptyEntries)
                    .Select(
                        static x => x.Split(EqualsSeparator, 2) switch
                        {
                            [ var x0 ] => KeyValuePair.Create(x0, LogBehavior.Show),
                            [ var x0, var x1 ] when Enum.TryParse(x1, true, out LogBehavior b) => KeyValuePair.Create(x0, b),
                            _ => (KeyValuePair<string, LogBehavior>?)null,
                        }
                    )
                    .OfType<KeyValuePair<string, LogBehavior>>()
            );
        }
    }

    // ... other properties
}
```

### B. Configuration Binding Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      HTTP Request                                â”‚
â”‚        Dynamic-Configuration: PermissionCheckEnabled=false       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           DynamicallyConfigureClassAwareOptions                  â”‚
â”‚                     .Configure(name, @class, options)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ConfigureCore()                               â”‚
â”‚  1. Load specs from HTTP header: {PermissionCheckEnabled=false}  â”‚
â”‚  2. Build in-memory IConfiguration                               â”‚
â”‚  3. Wrap in FilteredConfiguration                                â”‚
â”‚  4. configuration.Bind(options.MakeFiller())  â—„â”€â”€ BINDING HERE   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Microsoft.Extensions.Configuration.Binder     â”‚
â”‚  For each property on Filler:                                    â”‚
â”‚    - LogBehavior: set from config if present                     â”‚
â”‚    - ActivityLogLevel: set from config if present                â”‚
â”‚    - LoggedActivityNames: ??? (not in config, but binding reads) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**Document Version:** 1.0  
**Last Updated:** 2026-01-16  
**Next Review:** N/A  
