---
title: "Troubleshoot the startup sequence"
---

The **startup sequence** and **static methods** often hide **subtle and critical bugs** especially hard to detect and resolve.

For example:

- **Startup configurations**, such as <mark style="background-color:lightyellow">connection strings or resource access keys, may be incorrect or missing</mark>.
- **Static constructors** <mark style="background-color:lightyellow">and their dependencies can conceal subtle bugs</mark> that are difficult to troubleshoot.

Those places are usually __difficult to troubleshoot__ as standard telemetry may not be active when they are executed.

## Table of Contents

- [Startup sequence observability with Diginsight](#startup-sequence-observability-with-diginsight)
- [How to make the startup sequence observable](#how-to-make-the-startup-sequence-observable)
  - [STEP 01: Create the ObservabilityManager with its deferred LoggerFactory](#step-01-create-the-observabilitymanager-with-its-deferred-loggerfactory)
  - [STEP 02: Register for telemetry flush at the end of the startup sequence](#step-02-register-for-telemetry-flush-at-the-end-of-the-startup-sequence)
- [Use the ObservabilityRegistry to allow use of LoggerFactory access across dependencies](#use-the-observabilityregistry-to-allow-use-of-loggerfactory-access-across-dependencies)
  - [STEP 01: Change Observability class to receive the logger factory](#step-01-change-observability-class-to-receive-the-logger-factory)
  - [STEP 02: Update the startup sequence to register the LoggerFactory into the ObservabilityRegistry](#step-02-update-the-startup-sequence-to-register-the-loggerfactory-into-the-observabilityregistry)

## Startup sequence observability with Diginsight

Diginsight telemetry enables **observability for the full startup sequence** using the `DeferredLoggerFactory`. This factory **records the application flow** until the telemetry infrastructure is fully set up.

When startup completes, the recorded telemetry is flushed right before standard telemetry flow gathering begins. This ensures that any configuration problems or errors become visible.

The `ObservabilityRegistry` provides access to the logger factory across assemblies, including for static methods.

The code snippets below are available as working samples in the [telemetry.samples](https://github.com/diginsight/telemetry.samples) repository.

## How to make the startup sequence observable

The following code snippet shows the startup method of the `SampleWebApiWithStartupSequence` project, in in the [telemetry.samples](https://github.com/diginsight/telemetry.samples) repository:
![alt text](<images/000.02 SampleWebAPIWithStartupSequence.png>)

```c#
public static void Main(string[] args)
{
    using var observabilityManager = new ObservabilityManager();
    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));
    Observability.LoggerFactory = observabilityManager.LoggerFactory;

    WebApplication app;
    using (var activity = Observability.ActivitySource.StartMethodActivity(logger, new { args }))
    {
        var builder = WebApplication.CreateBuilder(args);
        var services = builder.Services;
        var configuration = builder.Configuration;
        var environment = builder.Environment;

        // Add logging and opentelemetry
        services.AddObservability(configuration, environment);
        // register for flush of recorded telemetry
        observabilityManager.AttachTo(services);

        services.AddControllers();
        services.AddEndpointsApiExplorer();
        services.AddSwaggerGen();

        // intercept build phase to flush recorded telemetry and register diginsight components
        builder.Host.UseDiginsightServiceProvider(true);
        app = builder.Build();

        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }

        app.UseHttpsRedirection();

        app.UseAuthorization();

        app.MapControllers();
    }

    app.Run();
}
```

### STEP 01: Create the `ObservabilityManager` with its deferred `LoggerFactory`

An `observabilityManager` is created at startup, __immediately after application start__:
```
using var observabilityManager = new ObservabilityManager();
ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));
Observability.LoggerFactory = observabilityManager.LoggerFactory;
```

__.NET logging is not configured or activated yet__, however observabilityManager __loggerFactory is recording__ all activities START, END and all explicit logging operations.

### STEP 02: Register for telemetry flush at the end of the startup sequence

After the `AddObservability()` method that registers diginsight telemetry.<br>

The `observabilityManager.AttachTo(services)` with its `services.FlushOnCreateServiceProvider()` registers the Flush operation for the recorded telemetry at the end of the startup sequence, during the dependency injection service provider creation (**the host .build()**).

```
// Add logging and opentelemetry
services.AddObservability(configuration, environment);
observabilityManager.AttachTo(services);
```

After services configuration, right __before the host build__, the telemetry and logging will be configured and activated.
The `UseDiginsightServiceProvider()` call will run the registered telemetry __Flush()__ and all the deferred logs will be flushed to the telemetry targets.

```
services.AddControllers();
services.AddEndpointsApiExplorer();
services.AddSwaggerGen();

builder.Host.UseDiginsightServiceProvider(true);
app = builder.Build();
```

API startup __will then show all logs recorded during startup__:

![alt text](<images/000.03 Resulting startup log.png>)

## Use the ObservabilityRegistry to allow use of LoggerFactory access across dependencies

It may happen that the `LoggerFactory` is needed in static methods or in other assemblies, where the `ObservabilityManager` is not available.

We can use the `ObservabilityRegistry` to access the `LoggerFactory` from anywhere in the code, even in static methods.

### STEP 01: Change Observability class to receive the logger factory

Any assembly using the `Observability` class can access the `LoggerFactory` by using the static property `Observability.LoggerFactory`.

With a simple static constructor, we can register the `Observability` class to receive the logger factory whenever it is changed into the ObservabilityRegistry:

```c#
internal static class Observability
{
    public static readonly ActivitySource ActivitySource = new(Assembly.GetExecutingAssembly().GetName().Name!);
    public static ILoggerFactory LoggerFactory { get; set; } = null!;

    static Observability() => ObservabilityRegistry.RegisterComponent(factory => LoggerFactory = factory);
}
```

![alt text](<images/001.00 Observability class with static constructor.png>)

### STEP 02: Update the startup sequence to register the LoggerFactory into the ObservabilityRegistry

Just after the `observabilityManager` is created, we can register the `LoggerFactory` into the `ObservabilityRegistry`:

![alt text](<images/002.00 Startup sequence registers LoggerFactory into ObservabilityRegistry.png>)

```c#
private static async Task Main(string[] args)
{
    using var observabilityManager = new ObservabilityManager();
    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));
    ObservabilityRegistry.RegisterLoggerFactory(observabilityManager.LoggerFactory);
```

Any component within your dependencies will then be able to use the `Observability.LoggerFactory` to create loggers and use Diginsight.

In the following example from Diginsight.Components, `Observability.LoggerFactory` is used to create a logger in the `GetItemQueryStreamIteratorObservable` static extensions method:

```c#
public static FeedIterator GetItemQueryStreamIteratorObservable(this Container container, string query, string? continuationToken = null, QueryRequestOptions? requestOptions = null)
{
    var loggerFactory = Observability.LoggerFactory;
    var logger = loggerFactory.CreateLogger(typeof(CosmosDbExtensions));
    using var activity = Observability.ActivitySource.StartMethodActivity(logger, () => new { query, continuationToken, requestOptions });
```

![alt text](<images/002.01 Static method observability example.png>)

This allows obtaining the following log output where GetItemQueryStreamIteratorObservable is made observable:
![alt text](<images/002.02 Static method observability output log.png>)