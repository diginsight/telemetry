---
title: "Troubleshoot the startup sequence"
---

## Table of Contents

- [Introduction](#introduction)
- [The Challenge](#the-challenge)
- [Diginsight Solution](#diginsight-solution)
- [Implementation Guide](#implementation-guide)
  - [Basic Setup](#basic-setup)
  - [Advanced: Cross-Assembly Access](#advanced-cross-assembly-access)

## Introduction

Application **startup sequences and static methods** often hide **critical bugs** that can be extremely difficult to detect and resolve. These issues normally occur before standard telemetry systems are active, leaving developers blind to what's happening during these crucial moments.

## The Challenge

During application startup, several problems commonly occur:

- **Configuration issues**: Missing connection strings, incorrect resource access keys, or invalid settings
- **Static constructor failures**: Dependencies that fail silently or throw exceptions in static initialization
- **Timing problems**: Components attempting to access services before they're properly initialized

The root problem is **observability gaps**: standard telemetry infrastructure isn't active during startup, making these issues nearly impossible to diagnose.

## Diginsight Solution

Diginsight telemetry solves this with the `DeferredLoggerFactory`, a recording logger that captures all startup activity before the telemetry system is ready. When startup completes, all recorded logs are flushed to your configured telemetry targets.

**Key benefits:**
- **Complete startup visibility**: Every method call, configuration load, and potential failure is recorded
- **No telemetry gaps**: Recording starts immediately, before any other systems
- **Cross-assembly support**: Static methods and external dependencies can access logging

::: {.callout-note}
All code examples are available in the [telemetry.samples](https://github.com/diginsight/telemetry.samples) repository.
:::

## Implementation Guide

### Basic Setup

Here's how to enable startup sequence observability in your application:
![alt text](<images/000.02 SampleWebAPIWithStartupSequence.png>)

```c#
public static void Main(string[] args)
{
    // Step 1: Create ObservabilityManager immediately
    using var observabilityManager = new ObservabilityManager();
    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));
    Observability.LoggerFactory = observabilityManager.LoggerFactory;

    WebApplication app;
    using (var activity = Observability.ActivitySource.StartMethodActivity(logger, new { args }))
    {
        var builder = WebApplication.CreateBuilder(args);

        // Step 2: Configure Diginsight and register for flush
        builder.Services.AddObservability(builder.Configuration, builder.Environment);
        observabilityManager.AttachTo(builder.Services);

        // Standard service registration
        builder.Services.AddControllers();
        builder.Services.AddEndpointsApiExplorer();
        builder.Services.AddSwaggerGen();

        // Step 3: Enable deferred logging flush during build
        builder.Host.UseDiginsightServiceProvider(true);
        app = builder.Build(); // Flush happens here

        // Configure pipeline
        if (app.Environment.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }

        app.UseHttpsRedirection();
        app.UseAuthorization();
        app.MapControllers();
    }

    app.Run();
}
```

#### Step 1: Initialize Deferred Logging

Create the `ObservabilityManager` as the very first action in your `Main` method:

```csharp
using var observabilityManager = new ObservabilityManager();
ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));
Observability.LoggerFactory = observabilityManager.LoggerFactory;
```

**What happens here:**
- The `ObservabilityManager` creates a recording logger that captures everything
- No telemetry infrastructure is needed yet - this works immediately
- The logger starts recording all method calls, timing, and log statements

#### Step 2: Register for Automatic Flush

After configuring Diginsight with `AddObservability()`, register the manager to flush when startup completes:

```csharp
builder.Services.AddObservability(builder.Configuration, builder.Environment);
observabilityManager.AttachTo(builder.Services);
```

**What happens here:**
- `AddObservability()` configures your standard telemetry (OpenTelemetry, logging providers, etc.)
- `AttachTo()` registers a callback to flush recorded logs when the service container is built
- All deferred logs will be sent to your configured telemetry targets

#### Step 3: Enable the Flush

Use the Diginsight service provider to trigger the flush during application build:

```csharp
builder.Host.UseDiginsightServiceProvider(true);
app = builder.Build(); // Flush happens automatically here
```

**Result:** Your application startup logs will show every detail of the initialization process:

![alt text](<images/000.03 Resulting startup log.png>)

### Advanced: Cross-Assembly Access

For static methods or code in external assemblies that need logging during startup, use the `ObservabilityRegistry`.

Create an `Observability` class in each assembly that needs startup logging:

```csharp
internal static class Observability
{
    public static readonly ActivitySource ActivitySource = new(Assembly.GetExecutingAssembly().GetName().Name!);
    public static ILoggerFactory LoggerFactory { get; set; } = null!;

    static Observability() => ObservabilityRegistry.RegisterComponent(factory => LoggerFactory = factory);
}
```

#### Register the Logger Factory

In your startup code, register the logger factory with the registry:

```csharp
using var observabilityManager = new ObservabilityManager();
ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));

// Register globally for cross-assembly access
ObservabilityRegistry.RegisterLoggerFactory(observabilityManager.LoggerFactory);
```

#### Use in Static Methods

Now any static method can access logging during startup:

```csharp
public static FeedIterator GetItemQueryStreamIteratorObservable(this Container container, string query, string? continuationToken = null, QueryRequestOptions? requestOptions = null)
{
    var loggerFactory = Observability.LoggerFactory;
    var logger = loggerFactory.CreateLogger(typeof(CosmosDbExtensions));
    using var activity = Observability.ActivitySource.StartMethodActivity(logger, () => new { query, continuationToken, requestOptions });
    
    // Method implementation with full observability
}
```

**Result:** Even static methods and external assemblies will appear in your startup logs:

![alt text](<images/002.02 Static method observability output log.png>)

With a simple static constructor, we can register the `Observability` class to receive the logger factory whenever it is changed into the ObservabilityRegistry:

```c#
internal static class Observability
{
    public static readonly ActivitySource ActivitySource = new(Assembly.GetExecutingAssembly().GetName().Name!);
    public static ILoggerFactory LoggerFactory { get; set; } = null!;

    static Observability() => ObservabilityRegistry.RegisterComponent(factory => LoggerFactory = factory);
}
```

![alt text](<images/001.00 Observability class with static constructor.png>)

### STEP 02: Update the startup sequence to register the LoggerFactory into the ObservabilityRegistry

Just after the `observabilityManager` is created, we can register the `LoggerFactory` into the `ObservabilityRegistry`:

![alt text](<images/002.00 Startup sequence registers LoggerFactory into ObservabilityRegistry.png>)

```c#
private static async Task Main(string[] args)
{
    using var observabilityManager = new ObservabilityManager();
    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));
    ObservabilityRegistry.RegisterLoggerFactory(observabilityManager.LoggerFactory);
```

Any component within your dependencies will then be able to use the `Observability.LoggerFactory` to create loggers and use Diginsight.

In the following example from Diginsight.Components, `Observability.LoggerFactory` is used to create a logger in the `GetItemQueryStreamIteratorObservable` static extensions method:

```c#
public static FeedIterator GetItemQueryStreamIteratorObservable(this Container container, string query, string? continuationToken = null, QueryRequestOptions? requestOptions = null)
{
    var loggerFactory = Observability.LoggerFactory;
    var logger = loggerFactory.CreateLogger(typeof(CosmosDbExtensions));
    using var activity = Observability.ActivitySource.StartMethodActivity(logger, () => new { query, continuationToken, requestOptions });
```

![alt text](<images/002.01 Static method observability example.png>)

This allows obtaining the following log output where GetItemQueryStreamIteratorObservable is made observable:
![alt text](<images/002.02 Static method observability output log.png>)