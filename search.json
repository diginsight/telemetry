[
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html",
    "title": "Troubleshoot the startup sequence",
    "section": "",
    "text": "The startup sequence and static methods often hide subtle and critical bugs especially hard to detect and resolve.\nFor example:\nThose places are usually difficult to troubleshoot as standard telemetry may not be active when they are executed.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Troubleshoot the startup sequence"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#startup-sequence-observability-with-diginsight",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#startup-sequence-observability-with-diginsight",
    "title": "Troubleshoot the startup sequence",
    "section": "Startup sequence observability with Diginsight",
    "text": "Startup sequence observability with Diginsight\nDiginsight telemetry enables observability for the full startup sequence by means of the DeferredLoggerFactory that provides recording the application flow until the telemetry infrastructure is set up. Upon startup completion, telemetry recording is flushed right before the standard telemetry flow gathering is started so that any configuration problem or error can be made visible.\nAlso, ObservabilityRegistry provides access to the logger factory across assemblies, also for static methods.\nThe code snippets below are available as working samples within the telemetry_samples repository.\nIn particular the steps shown below explain how the startup sequence can be made observable on the SampleWebApi within the telemetry_samples repository.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Troubleshoot the startup sequence"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#how-to-make-the-startup-sequence-observable",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#how-to-make-the-startup-sequence-observable",
    "title": "Troubleshoot the startup sequence",
    "section": "How to make the startup sequence observable",
    "text": "How to make the startup sequence observable\nThe following code snippet shows the startup method of the SampleWebApiWithStartupSequence project: \npublic static void Main(string[] args)\n{\n    using var observabilityManager = new ObservabilityManager();\n    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));\n    Observability.LoggerFactory = observabilityManager.LoggerFactory;\n\n    WebApplication app;\n    using (var activity = Observability.ActivitySource.StartMethodActivity(logger, new { args }))\n    {\n        var builder = WebApplication.CreateBuilder(args);\n        var services = builder.Services;\n        var configuration = builder.Configuration;\n        var environment = builder.Environment;\n\n        // Add logging and opentelemetry\n        services.AddObservability(configuration, environment);\n        // register for flush of recorded telemetry\n        observabilityManager.AttachTo(services);\n\n        services.AddControllers();\n        services.AddEndpointsApiExplorer();\n        services.AddSwaggerGen();\n\n        // intercept build phase to flush recorded telemetry and register diginsight components\n        builder.Host.UseDiginsightServiceProvider(true);\n        app = builder.Build();\n\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseSwagger();\n            app.UseSwaggerUI();\n        }\n\n        app.UseHttpsRedirection();\n\n        app.UseAuthorization();\n\n        app.MapControllers();\n    }\n\n    app.Run();\n}\n\nSTEP 01: Create the ObservabilityManager with the deferred LoggerFactory\nAn observabilityManager is created at startup, immediately after application start:\nusing var observabilityManager = new ObservabilityManager();\nILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));\nObservability.LoggerFactory = observabilityManager.LoggerFactory;\n.NET logging is not configured or activated yet, however observabilityManager loggerFactory is recording all activities START, END and all explicit logging operations.\n\n\nSTEP 02: Register for telemetry flush at the end of the startup sequence\nAfter the AddObservability() method that registers diginsight telemetry.\nThe observabilityManager.AttachTo(services) with its services.FlushOnCreateServiceProvider() registers the Flush operation for the recorded telemetry at the end of the startup sequence, during the dependency injection service provider creation (the host .build()).\n// Add logging and opentelemetry\nservices.AddObservability(configuration, environment);\nobservabilityManager.AttachTo(services);\nAfter services configuration, right before the host build, the telemetry and logging will be configured and activated. The UseDiginsightServiceProvider() call will run the registered telemetry Flush() and all the deferred logs will be flushed to the telemetry targets.\nservices.AddControllers();\nservices.AddEndpointsApiExplorer();\nservices.AddSwaggerGen();\n\nbuilder.Host.UseDiginsightServiceProvider(true);\napp = builder.Build();\nAPI startup will then show all logs recorded during startup:\n\n\n\nalt text",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Troubleshoot the startup sequence"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#use-the-observabilityregistry-to-allow-use-of-loggerfactory-access-across-dependencies",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#use-the-observabilityregistry-to-allow-use-of-loggerfactory-access-across-dependencies",
    "title": "Troubleshoot the startup sequence",
    "section": "Use the ObservabilityRegistry to allow use of LoggerFactory access across dependencies",
    "text": "Use the ObservabilityRegistry to allow use of LoggerFactory access across dependencies\nIt may happen that the LoggerFactory is needed in static methods or in other assemblies, where the ObservabilityManager is not available.\nWe can use the ObservabilityRegistry to access the LoggerFactory from anywhere in the code, even in static methods.\n\nSTEP 01: Change Observability class to receive the logger factory\nAny assembly using the Observability class can access the LoggerFactory by using the static property Observability.LoggerFactory.\nWith a simple static constructor, we can register the Observability class to receive the logger factory whenever it is changed into the ObservabilityRegistry:\ninternal static class Observability\n{\n    public static readonly ActivitySource ActivitySource = new(Assembly.GetExecutingAssembly().GetName().Name!);\n    public static ILoggerFactory LoggerFactory { get; set; } = null!;\n\n    static Observability() =&gt; ObservabilityRegistry.RegisterComponent(factory =&gt; LoggerFactory = factory);\n}\n\n\n\nalt text\n\n\n\n\nSTEP 02: Update the startup sequence to register the LoggerFactory into the ObservabilityRegistry\nJust after the observabilityManager is created, we can register the LoggerFactory into the ObservabilityRegistry:\n\n\n\nalt text\n\n\nprivate static async Task Main(string[] args)\n{\n    using var observabilityManager = new ObservabilityManager();\n    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));\n    ObservabilityRegistry.RegisterLoggerFactory(observabilityManager.LoggerFactory);\nAny component within your dependencies will then be able to use the Observability.LoggerFactory to create loggers and use Diginsight.\nIn the following example from Diginsight.Components, Observability.LoggerFactory is used to create a logger in the GetItemQueryStreamIteratorObservable static extensions method:\npublic static FeedIterator GetItemQueryStreamIteratorObservable(this Container container, string query, string? continuationToken = null, QueryRequestOptions? requestOptions = null)\n{\n    var loggerFactory = Observability.LoggerFactory;\n    var logger = loggerFactory.CreateLogger(typeof(CosmosDbExtensions));\n    using var activity = Observability.ActivitySource.StartMethodActivity(logger, () =&gt; new { query, continuationToken, requestOptions });\n\n\n\nalt text\n\n\nThis allows obtaining the following log output where GetItemQueryStreamIteratorObservable is made observable:",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Troubleshoot the startup sequence"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#table-of-contents",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#table-of-contents",
    "title": "Troubleshoot the startup sequence",
    "section": "Table of Contents",
    "text": "Table of Contents\n\nStartup sequence observability with Diginsight\nHow to make the startup sequence observable\n\nSTEP 01: Create the ObservabilityManager with its deferred LoggerFactory\nSTEP 02: Register for telemetry flush at the end of the startup sequence\n\nUse the ObservabilityRegistry to allow use of LoggerFactory access across dependencies\n\nSTEP 01: Change Observability class to receive the logger factory\nSTEP 02: Update the startup sequence to register the LoggerFactory into the ObservabilityRegistry",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Troubleshoot the startup sequence"
    ]
  }
]