[
  {
    "objectID": "src/docs/about.html",
    "href": "src/docs/about.html",
    "title": "Diginsight",
    "section": "",
    "text": "Diginsight is a free opensource project."
  },
  {
    "objectID": "src/docs/about.html#project-members",
    "href": "src/docs/about.html#project-members",
    "title": "Diginsight",
    "section": "Project members",
    "text": "Project members\n\n\n\n\n\n\n\n\n\nFilippo Mineo\nMilan, Italy\n\n\n\nAlessandro Avila\nMilan, Italy\n\n\n\nDario Airoldi\nMilan, Italy"
  },
  {
    "objectID": "src/docs/about.html#other-contributors",
    "href": "src/docs/about.html#other-contributors",
    "title": "Diginsight",
    "section": "Other Contributors",
    "text": "Other Contributors\nChayashree Gollahalli | Bhangalore, India Carlo Bollini | Milan, Italy Metushi Margil | Milan, Italy Maurizio Iacovella | Milan, Italy Matteo Delli Rocioli | Milan, Italy Raffaele Fanizzi | Milan, Italy"
  },
  {
    "objectID": "src/docs/02. Advanced/18.00 - Use class aware configurations to support comonent level or class level configurations.html",
    "href": "src/docs/02. Advanced/18.00 - Use class aware configurations to support comonent level or class level configurations.html",
    "title": "Use class aware configurations",
    "section": "",
    "text": "Article in progress.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Use class aware configurations"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/18.00 - Use class aware configurations to support comonent level or class level configurations.html#use-class-aware-configurations-to-support-comonent-level-or-class-level-configurations",
    "href": "src/docs/02. Advanced/18.00 - Use class aware configurations to support comonent level or class level configurations.html#use-class-aware-configurations-to-support-comonent-level-or-class-level-configurations",
    "title": "Use class aware configurations",
    "section": "",
    "text": "Article in progress.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Use class aware configurations"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/15.00 - Customize diginsight log streams row content.html",
    "href": "src/docs/02. Advanced/15.00 - Customize diginsight log streams row content.html",
    "title": "Customize diginsight log streams",
    "section": "",
    "text": "Article in progress.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Customize diginsight log streams"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/15.00 - Customize diginsight log streams row content.html#customize-diginsight-log-streams-row-content",
    "href": "src/docs/02. Advanced/15.00 - Customize diginsight log streams row content.html#customize-diginsight-log-streams-row-content",
    "title": "Customize diginsight log streams",
    "section": "",
    "text": "Article in progress.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Customize diginsight log streams"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/13.00 - Customize entities rendering on diginsight log streams.html",
    "href": "src/docs/02. Advanced/13.00 - Customize entities rendering on diginsight log streams.html",
    "title": "Customize entities rendering",
    "section": "",
    "text": "Diginsight provides automatic rendering for entities such as method input payloads or return values.\nEntities rendering is performed automatically for simple types and also for complex types with fields and properties.\nThis article discusses how rendering is handled ensuring limited performance impact and how the developer can customize rendering for its own entities or for entities from other packages.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Customize entities rendering"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/13.00 - Customize entities rendering on diginsight log streams.html#howto-customize-entities-rendering-on-diginsight-log-streams",
    "href": "src/docs/02. Advanced/13.00 - Customize entities rendering on diginsight log streams.html#howto-customize-entities-rendering-on-diginsight-log-streams",
    "title": "Customize entities rendering",
    "section": "",
    "text": "Diginsight provides automatic rendering for entities such as method input payloads or return values.\nEntities rendering is performed automatically for simple types and also for complex types with fields and properties.\nThis article discusses how rendering is handled ensuring limited performance impact and how the developer can customize rendering for its own entities or for entities from other packages.",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Customize entities rendering"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/13.00 - Customize entities rendering on diginsight log streams.html#additional-information",
    "href": "src/docs/02. Advanced/13.00 - Customize entities rendering on diginsight log streams.html#additional-information",
    "title": "Customize entities rendering",
    "section": "Additional Information",
    "text": "Additional Information\nFor simple types rendering is performed in automatic and intuitive way. the image below shows log for DoSomeWork, StepOne and StepTwo methods that return integer values.\n\n\n\nalt text\n\n\nFor complex types, by default, entities are rendered with their property values in the order chosen by the compiler.\n\n\n\nalt text\n\n\n\nCustomize properties rendering\nThe developer can use attributes LogStringableMember NonLogStringableMember to decide members to be shown with a specific order and members to be excluded from rendering. The image below shows a custom entity where order is defined for members and where non relevant members are excluded by means of the NonLogStringableMember attribute:\n\n\n\nalt text\n\n\n\n\nCustomize the full entities rendering\nTODO: In Progress",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Customize entities rendering"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/11.01 - HowTo - Use dynamic configuration to manage dynamic options, at runtime.html",
    "href": "src/docs/01. Concepts/11.01 - HowTo - Use dynamic configuration to manage dynamic options, at runtime.html",
    "title": "Use Dynamic-Configuration to manage configurations and feature flags dynamically at runtime",
    "section": "",
    "text": "Diginsight telemetry supports dynamic configuration to hot switch configuration values, based on http headers (or other information). As an example, lets assume that a Web Application implements a concurrency option such as the following:\nWith diginsight, the developer can register such a configuration so that it can be overridden at runtime by means of the Dynamic-Configuration http request header, for specific calls.\nThe following paragraphs show how to reguster and use such a dynamic configuration. The following code snippets can be found into the S01_00_SampleWebAPI project in Diginsight telemetry.samples repository.",
    "crumbs": [
      "Home",
      "Concepts",
      "Use Dynamic-Configuration to manage configurations and feature flags dynamically at runtime"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/11.01 - HowTo - Use dynamic configuration to manage dynamic options, at runtime.html#additional-information",
    "href": "src/docs/01. Concepts/11.01 - HowTo - Use dynamic configuration to manage dynamic options, at runtime.html#additional-information",
    "title": "Use Dynamic-Configuration to manage configurations and feature flags dynamically at runtime",
    "section": "Additional information",
    "text": "Additional information\nThe snippet below, shows the ConcurrencyOptions class used for loading the MaxConcurrency settings. A marker interface IDynamicallyConfigurable is used to mark the class as dynamically configurable.\npublic class ConcurrencyOptions : IDynamicallyConfigurable\n{\n    public int? MaxConcurrency { get; set; }\n}\nThe developer can register the configuration within the startup sequence, as shown below:\nservices.ConfigureClassAware&lt;ConcurrencyOptions&gt;(configuration.GetSection(\"AppSettings\"))\n    .DynamicallyConfigureClassAware&lt;ConcurrencyOptions&gt;();\nThe image below shows the sample code where th concurrencyOptionsMonitor is injected into the constructor of the WeatherForecastController class and used into the Get() method. \nIn this way, ConcurrencyOptions options will be overridable by means of the Dynamic-Configuration http request header.\nThe image below shows a call to the S01_00_SampleWebAPI sample api where MaxConcurrency value 10 is loaded from the appSettings.json:\n\n\n\nalt text\n\n\nThe output log below shows the MaxConcurrency value of 10 read from the appSettings.json configuration file: \nThe image below shows a call to the S01_00_SampleWebAPI sample api where MaxConcurrency value is overridden to 1 by means of the Dynamic-Configuration http request header:\n\n\n\nalt text\n\n\nThe output log below shows the MaxConcurrency value of 1 overridden by means of the Dynamic-Configuration http request header:\n\n\n\nalt text",
    "crumbs": [
      "Home",
      "Concepts",
      "Use Dynamic-Configuration to manage configurations and feature flags dynamically at runtime"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html",
    "href": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html",
    "title": "HowTo: Configure diginsight telemetry to the remote tools",
    "section": "",
    "text": "Diginsight is a very thin layer built on .Net System.Diagnostics Activity API and ILogger API.\nIn particular, standard .Net System.Diagnostics activities and ILogger telemetry are sent to remote tools by means of OpenTelemetry and/or Prometheus. This enables in sending the full diginsight application flow to the remote tools.\nThis article discusses how we can configure Diginsight telemetry to remote tools such as Azure Monitor or Grafana. Also, the article shows how such telemetry can be easily analyzed on Azure Monitor tools such as the Transaction Search and Transaction Detail, the Azure Monitor Metrics, Logs or Azure Monitor Dashboards.\nThe code snippets below are available as working samples within the telemetry.samples repository.\nArticle HOWTO - Use Diginsight Samples.md: explores how we can use diginsight samples to test and understand integration of Diginsight telemetry in our own projects.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the remote tools"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-01---add-a-package-reference-to-the-packages-diginsight.diagnostics.aspnetcore.opentelemetry",
    "href": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-01---add-a-package-reference-to-the-packages-diginsight.diagnostics.aspnetcore.opentelemetry",
    "title": "HowTo: Configure diginsight telemetry to the remote tools",
    "section": "STEP 01 - Add a package reference to the packages Diginsight.Diagnostics.AspNetCore.OpenTelemetry",
    "text": "STEP 01 - Add a package reference to the packages Diginsight.Diagnostics.AspNetCore.OpenTelemetry\nIn the first step you can just add a diginsight references to your code:",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the remote tools"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-02---configure-telemetry-on-the-startup-sequence",
    "href": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-02---configure-telemetry-on-the-startup-sequence",
    "title": "HowTo: Configure diginsight telemetry to the remote tools",
    "section": "STEP 02 - Configure telemetry on the Startup sequence",
    "text": "STEP 02 - Configure telemetry on the Startup sequence\nThe S01_02_SampleWebAPIWithOpentelemetry sample shows an example WebApi fully integrated with OpenTelemetry and AzureMonitor.\nThe Program.Main entry point activates telemetry by means of AddObservability() .UseDiginsightServiceProvider() as shown below.\nThe startup sequence is identical to the one seen for the local Console and Log4Net providers. The difference lies in AddObservability() that, in addition to Console and Log4Net providers, enables OpenTelemetry for AzureMonitor.\npublic static void Main(string[] args)\n{\n    // this enables sending telemetry for the startup sequence\n    // telemetry is recorded until ServiceProvider creation\n    // after that, recorded telemetry is sent to the configured registered providers\n    // (eg. AzureMonitor, Console, Log4Net) \n    using var observabilityManager = new ObservabilityManager();\n    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));\n    Observability.LoggerFactory = observabilityManager.LoggerFactory;\n\n    WebApplication app;\n    using (var activity = Observability.ActivitySource.StartMethodActivity(logger, new { args }))\n    {\n        var builder = WebApplication.CreateBuilder(args);\n        var services = builder.Services;\n        var configuration = builder.Configuration;\n        var environment = builder.Environment;\n\n        // Add logging and opentelemetry providers\n        services.AddObservability(configuration, environment, out IOpenTelemetryOptions openTelemetryOptions);\n\n        // registers recorded telemetry for flush after ServiceProvider creation\n        observabilityManager.AttachTo(services);\n        services.TryAddSingleton&lt;IActivityLoggingSampler, NameBasedActivityLoggingSampler&gt;();\n\n        services.AddControllers();\n        services.AddEndpointsApiExplorer();\n        services.AddSwaggerGen();\n\n        // use diginsight service provider \n        // this enables telemetry initialization at service provider creation\n        builder.Host.UseDiginsightServiceProvider(true);\n        app = builder.Build();\n\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseSwagger();\n            app.UseSwaggerUI();\n        }\n\n        app.UseHttpsRedirection();\n\n        app.UseAuthorization();\n\n        app.MapControllers();\n    }\n\n    app.Run();\n}\nin the code above: - AddObservability() configures log for the application Console, log4net file log and also for Opentelemetry. - UseDiginsightServiceProvider() is used to activate diginsight during the service provider build() process.\nPlease note that AddObservability() is implemented as an extension method that calls AddLogging() with: - AddDiginsightConsole(): this methods configures the Console log provider with some formatting options \n\nAddDiginsightLog4Net(): this methods configures a rolling File log on the user profile folder. \nservices.Configure(openTelemetryConfiguration) and AddDiginsightOpenTelemetry(): this methods configures the OpenTelemetry provider with the AzureMonitor connection string. In case EnableMetrics is set to true, openTelemetryBuilder.WithMetrics is called to send predefined metrics such as the span_duration metric for configured methods. In case EnableTraces is set to true, openTelemetryBuilder.WithTracing is called to include ILogger traces into the opentelemetry flow sent to the remote tools. \n\n\nOpentelemetry flow is regulated by Opentelemetry options that include the AzureMonitorConnectionString as well as the EnableTraces and EnableMetrics flags.\n\"OpenTelemetry\": {\n    \"EnableTraces\": true,\n    \"EnableMetrics\": true,\n    \"AzureMonitorConnectionString\": \"\",\n    \"ActivitySources\": [\n        \"Azure.Cosmos.Operation\",\n        \"Azure.Storage.Blobs.BlobBaseClient\",\n        \"Microsoft.AspNetCore\",\n        \"Diginsight.*\",\n        \"S01_02_SampleWebAPIWithOpentelemetry\"\n    ],\n    \"Meters\": [\n        \"S01_02_SampleWebAPIWithOpentelemetry\"\n    ],\n    \"ExcludedHttpHosts\": [\n        \"login.microsoftonline.com\",\n        \".documents.azure.com\",\n        \".applicationinsights.azure.com\",\n        \".monitor.azure.com\",\n        \".b2clogin.com\"\n    ],\n    \"DurationMetricTags\": [\n        \"category_name\",\n        \"user_company\",\n        \"plant_name\",\n        \"plant_company\",\n        \"max_concurrency\"\n    ]\n},\nIn the above options, the ActivitySources section includes the activity sources that are used to send telemetry to the remote tools. For every assembly, the span_duration metric is sent with latencies of method executions. We’ll see that Tags can be attached to the span_duration metric to allow distinguishing durations in different conditions. The DurationMetricTags section includes the tags allowed for the span_duration metric",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the remote tools"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-03---add-telemetry-to-code-with-startmethodactivity-and-ilogger-statements",
    "href": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-03---add-telemetry-to-code-with-startmethodactivity-and-ilogger-statements",
    "title": "HowTo: Configure diginsight telemetry to the remote tools",
    "section": "STEP 03 - Add telemetry to code with StartMethodActivity() and ILogger Statements",
    "text": "STEP 03 - Add telemetry to code with StartMethodActivity() and ILogger Statements\nWe are now ready to add instrumentation to the code and make the application flow observable.\nThe snippet below shows how to add telemetry to the GetWeatherForecast() method of the WeatherForecastController class:\n[HttpGet(Name = \"GetWeatherForecast\")]\npublic async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; Get()\n{\n    using var activity = Observability.ActivitySource.StartMethodActivity(logger);\n\n    var maxConcurrency = concurrencyOptionsMonitor.CurrentValue?.MaxConcurrency ?? -1; logger.LogDebug(\"maxConcurrency: {maxConcurrency}\", maxConcurrency);\n    activity.SetTag(\"max_concurrency\", maxConcurrency.ToString(\"D\"));\n    var options = new ParallelOptions() { MaxDegreeOfParallelism = maxConcurrency };\n\n    int[] ia = new int[20];\n    int index = 0;\n    var queue = new ConcurrentQueue&lt;WeatherForecast&gt;();\n    await Parallel.ForEachAsync(ia, options, async (i, ct) =&gt;\n    {\n        index++;\n        var randomTemperature = Random.Shared.Next(-20, 55);\n        logger.LogDebug(\"index {index}, randomTemperature: {randomTemperature}\", index, randomTemperature);\n        var weatherForecast = new WeatherForecast\n        {\n            Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),\n            TemperatureC = randomTemperature,\n            Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n        };\n        \n        Thread.Sleep(100); \n        queue.Enqueue(weatherForecast);\n    });\n\n    var res = queue.ToArray();\n    activity?.SetOutput(res);\n    return res;\n}\nin the snippet above: - using var activity = Observability.ActivitySource.StartMethodActivity(logger); is added to provide observability of method start and end - logger.LogDebug(\"randomTemperature: {randomTemperature}\", randomTemperature); is usd to log the randomTemperature value, during the method execution. - activity.SetOutput(result); is used to add the method result to the method END event. - activity.SetTag(\"max_concurrency\", maxConcurrency.ToString(\"D\"));: is used to add the max_concurrency tag to the span_duration metric sent to the remote tools. this will allow comparing latencies for the same method, with different max_concurrency values.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the remote tools"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-04---run-your-code-and-look-at-the-resulting-application-flow",
    "href": "src/docs/01. Concepts/02.00 - HowTo - configure diginsight telemetry to the remote tools.html#step-04---run-your-code-and-look-at-the-resulting-application-flow",
    "title": "HowTo: Configure diginsight telemetry to the remote tools",
    "section": "STEP 04 - run your code and look at the resulting application flow",
    "text": "STEP 04 - run your code and look at the resulting application flow\nThe image below shows the application flow generated by WeatherForecastController.get method.\nThe image belpw shows the sample method execution, with different maxConcurrency levels: | maxConcurrency 1 | maxConcurrency 5 | |——————|———————| |  |  |\nthe image below shows the corresponding transactions on the Azure Monitor. | maxConcurrency 1 | maxConcurrency 5 | |——————|———————| |  |  |\nan easy query on the Azure Monitor can be used to get the span_duration metric for the WeatherForecastController.get method for different max_concurrency values.\ncustomMetrics\n| where name == \"diginsight.span_duration\"\n| extend maxConcurrency = coalesce(tostring(customDimensions.max_concurrency), \"-1\")\n| extend span_name = tostring(customDimensions.span_name)\n| where customDimensions[\"span_name\"] contains \"Controller\"\n| where customDimensions[\"span_name\"] !contains \".ctor\"\n\n\n\nalt text\n\n\nrendering a columnchart it is easy to understand that the max_concurrency value 1 is producing the highest span_durations.\ncustomMetrics\n| where name == \"diginsight.span_duration\"\n| extend maxConcurrency = coalesce(tostring(customDimensions.max_concurrency), \"-1\")\n| extend span_name = tostring(customDimensions.span_name)\n| where customDimensions[\"span_name\"] contains \"Controller\"\n| where customDimensions[\"span_name\"] !contains \".ctor\"\n| summarize avgSpanDuration = avg(value/valueCount) by span_name, maxConcurrency\n| order by avgSpanDuration asc  \n| render columnchart with (kind=unstacked, xcolumn=maxConcurrency, ycolumns=avgSpanDuration)\n\n\n\nalt text",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the remote tools"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/00.01 - Observability Concepts.html",
    "href": "src/docs/01. Concepts/00.01 - Observability Concepts.html",
    "title": "Application Observability Concepts",
    "section": "",
    "text": "Application observability is about aggregating, correlating and analyzing the following key elements:\nThe image below shows examples about the 3 observability elements into local text based streams:  The image below shows examples about the 3 observability elements into Azure Monitor Performance Management (APM) Tools:\nDiginsight makes observability easy as: &gt;- it integrates the 3 observability elements (Log, Traces, Metrics) into high performance text-based streams such as traditional File logs, the Console log or the Azure Streaming log. &gt;- it publishes the 3 observability elements to OpenTelemetry and allowing application analysis by means of remote APM tools such as Azure Monitor and Grafana.",
    "crumbs": [
      "Home",
      "Concepts",
      "Application Observability Concepts"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/00.01 - Observability Concepts.html#additional-information",
    "href": "src/docs/01. Concepts/00.01 - Observability Concepts.html#additional-information",
    "title": "Application Observability Concepts",
    "section": "Additional Information",
    "text": "Additional Information\nApplication flow observability is provided leveraging existing .Net ILogger and System Diagnostics classes so that diginsight telemetry can be mixed and analyzed with other components telemetry, as long as they rely on the same standard framework classes. Observability for remote tools is provided by means of OpenTelemetry so that telemetry data can be targeted to Azure Monitor and also other analysis tools such as Prometheus/Graphana.\nDiginsight application flow rendering is: - consistent across tools: every information or metric visible on the local text based streams can be published and observed on the remote analysis tools (eg. on Appinsight Transaction detail or Appinsight Metrics). \n\nconsistent with code: the application flow is published with information about classes, method names and call nesting so the ‘gap’ from telemetry and code is shortened for application developers and site reliability engineers. \nconsistent across applications application flow published in the same way for all applications. so it is easily readable for peopble without background knowledge on the application logic.  \n\nDiginsight log layout and automatic rendering for entities can be fully customized to ensure best readability of the application flow.\nParagraph Getting Started discusses basic steps we can follow to integrate diginsight telemetry.",
    "crumbs": [
      "Home",
      "Concepts",
      "Application Observability Concepts"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html",
    "href": "src/docs/00. Getting Started/Getting Started.html",
    "title": "Getting Started with Diginsight",
    "section": "",
    "text": "Diginsight streamlines logging and OpenTelemetry integration embracing .NET System.Diagnostics standard notation for activity tracing.\nIn the present article we’ll understand basic steps to enable application flow observability to local text based streams such as the application console or a log4net file, as well ass to the remote analysis tools such as Azure Monitor.\nThe code snippets below demonstrate how to use the .NET System.Diagnostics API to instrument a code span:\nwhere, StartMethodActivity: - gathers automatically the method name, - renders automatically the method payload - writes the Span START and END to the logger variable\nand SetOutput stores the method result for rendering within method END line. This code generates a log stream like the following:\nStandard rows within the section can be logged with ILogger&lt;&gt; methods.\nthis generates a log raw as shown below",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#steps-to-use-diginsight",
    "href": "src/docs/00. Getting Started/Getting Started.html#steps-to-use-diginsight",
    "title": "Getting Started with Diginsight",
    "section": "Steps to use Diginsight",
    "text": "Steps to use Diginsight\nYou can obtain a console log or file log with diginsight by means of the following steps. The code snippets below are available as working samples within the telemetry.samples repository.\nArticle HOWTO - Use Diginsight Samples: explores how we can use diginsight samples to test and understand integration of Diginsight telemetry in our own projects.",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#step-01---add-a-package-reference-to-the-package-diginsight.diagnostics-or-diginsight.diagnostics.log4net",
    "href": "src/docs/00. Getting Started/Getting Started.html#step-01---add-a-package-reference-to-the-package-diginsight.diagnostics-or-diginsight.diagnostics.log4net",
    "title": "Getting Started with Diginsight",
    "section": "STEP 01 - Add a package reference to the package Diginsight.Diagnostics or Diginsight.Diagnostics.Log4Net",
    "text": "STEP 01 - Add a package reference to the package Diginsight.Diagnostics or Diginsight.Diagnostics.Log4Net\n: {#step01 .sidebar=“STEP 01 - Add Package Reference”}\nIn the first step you can just add a diginsight reference to your code:",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#step-02---configure-logging-within-the-startup-sequence",
    "href": "src/docs/00. Getting Started/Getting Started.html#step-02---configure-logging-within-the-startup-sequence",
    "title": "Getting Started with Diginsight",
    "section": "STEP 02 - Configure logging within the Startup sequence",
    "text": "STEP 02 - Configure logging within the Startup sequence\n: {#step01 .sidebar[STEP 02 - Configure logging]}\nin the second step you can configure the startup sequence to enable diginsight log:\n...\nvar builder = WebApplication.CreateBuilder(args);\nvar services = builder.Services;\nvar configuration = builder.Configuration;\n\nservices.ConfigureClassAware&lt;DiginsightActivitiesOptions(configuration.GetSection(\"Diginsight:Activities\"));\nservices.Configure&lt;DiginsightConsoleFormatterOptions(configuration.GetSection(\"Diginsight:Console\"));\nservices.AddLogging(\n    loggingBuilder =&gt;\n    {\n        loggingBuilder.ClearProviders();\n        if (configuration.GetValue(\"Observability:ConsoleEnabled\", true))\n        {\n            loggingBuilder.AddDiginsightConsole();\n        }\n        if (configuration.GetValue(\"Observability:Log4NetEnabled\", true))\n        {\n            //loggingBuilder.AddDiginsightLog4Net(\"log4net.config\");\n            loggingBuilder.AddDiginsightLog4Net(static sp =&gt;\n            {\n                IHostEnvironment env = sp.GetRequiredService&lt;IHostEnvironment&gt;();\n                string fileBaseDir = env.IsDevelopment()\n                        ? Environment.GetFolderPath(Environment.SpecialFolder.UserProfile, Environment.SpecialFolderOption.DoNotVerify)\n                        : $\"{Path.DirectorySeparatorChar}home\";\n                return new IAppender[]\n                {\n                    new RollingFileAppender()\n                    {\n                        ...\n                    },\n                };\n            },\n            static _ =&gt; log4net.Core.Level.All);\n        }\n    }\n);\nservices.TryAddSingleton&lt;IActivityLoggingSampler,NameBasedActivityLoggingSampler&gt;();\n\nservices.AddControllers();\nservices.AddEndpointsApiExplorer();\nservices.AddSwaggerGen();\n...\nin this case: - AddDiginsightConsole() is used to enabled log to the application Console. - AddDiginsightLog4Net() is used to enabled file log by means of log4net.\nalso, - the Diginsight:Activities section can be used to specify enabled ActivitySources and whether Activity logging is enabled.  - the Diginsight:Console section can be used to specify console options.  - NameBasedActivityLoggingSampler filters log based on Diginsight:Activities section.",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#step-03---add-telemetry-to-code-with-startmethodactivity-and-ilogger-statements",
    "href": "src/docs/00. Getting Started/Getting Started.html#step-03---add-telemetry-to-code-with-startmethodactivity-and-ilogger-statements",
    "title": "Getting Started with Diginsight",
    "section": "STEP 03 - Add telemetry to code with StartMethodActivity() and ILogger Statements",
    "text": "STEP 03 - Add telemetry to code with StartMethodActivity() and ILogger Statements\n: {#step01 .sidebar[STEP 03 - Add telemetry]}\nwe are now ready to add instrumentation to the code and make the application flow observable:\npublic async Task&lt;Plant&gt; GetPlantByIdAsync([FromRoute] Guid plantId)\n{\n    using var activity = Observability.ActivitySource.StartMethodActivity(logger, () =&gt; new { plantId });\n\n    ...\n\n    activity?.SetOutput(plant);\n    return plant;\n}\nPlease, note that in this case the method payload is passed to StartMethodActivity by means of a delegate notation so that the payload class allocation can be avoided when logging or payload rendering is disabled.",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#step-04---enable-opentelemetry-and-send-data-to-the-remote-tools",
    "href": "src/docs/00. Getting Started/Getting Started.html#step-04---enable-opentelemetry-and-send-data-to-the-remote-tools",
    "title": "Getting Started with Diginsight",
    "section": "STEP 04 - Enable OpenTelemetry and send data to the remote tools",
    "text": "STEP 04 - Enable OpenTelemetry and send data to the remote tools\nWith few changes to the startup sequence, telemetry can be sent to the remote tools. Telemetry to the local tools is less expensive, more efficient, well protected and, often, it is not even persisted. So, telemetry to the local tools can include verbose data with the maximum level of information. Telemetry to the remote tools is more expensive (in cost and performance) so it will normally include only critical and warning non verbose information.\nIn our samples we enable openteemetry by means of the AddObservability() extension method that essentially: - Configures Opentelemetry options - Registers Opentelemetry logging provider - Configures tracing to the remote tools - Configures metrics to the remote tools\nthe startup sequence will resemble as shown below:\n...\nvar builder = WebApplication.CreateBuilder(args);\nvar services = builder.Services;\nvar configuration = builder.Configuration;\nvar environment = builder.Environment;\n\n// Adds logging and opentelemetry\nservices.AddObservability(configuration, environment, out IOpenTelemetryOptions openTelemetryOptions); \n\nobservabilityManager.AttachTo(services);\nservices.TryAddSingleton&lt;IActivityLoggingSampler, NameBasedActivityLoggingSampler&gt;();\n\nservices.AddControllers();\n// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\nservices.AddEndpointsApiExplorer();\nservices.AddSwaggerGen();\n\nbuilder.Host.UseDiginsightServiceProvider(true);\napp = builder.Build();\n\n// Configure the HTTP request pipeline.\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n...\nAs a reference example you can use the SampleWebAPI into the telemetry.samples repository.\n\n\n\nalt text\n\n\nDetails about opentelemetry configuration is available here: HowTo: Configure diginsight telemetry to the remote tools.",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#build-and-test",
    "href": "src/docs/00. Getting Started/Getting Started.html#build-and-test",
    "title": "Getting Started with Diginsight",
    "section": "Build and Test",
    "text": "Build and Test\nClone the repository, open and build solution Common.Diagnostics.sln. run EasySample and open the log file in your *** folder.",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#contribute",
    "href": "src/docs/00. Getting Started/Getting Started.html#contribute",
    "title": "Getting Started with Diginsight",
    "section": "Contribute",
    "text": "Contribute\nContribute to the repository with your pull requests.\n\nASP.NET Core\nVisual Studio Code",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "src/docs/00. Getting Started/Getting Started.html#license",
    "href": "src/docs/00. Getting Started/Getting Started.html#license",
    "title": "Getting Started with Diginsight",
    "section": "License",
    "text": "License\nSee the LICENSE file for license rights and limitations (MIT).",
    "crumbs": [
      "Home",
      "Getting Started"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Diginsight telemetry is a set .Net packages that that provides automatic observability for dotnet applications. In particular, the full application flow is made available to local text based streams such as traditional file logs, the Console Log or the Azure Streaming Log and also to remote analysis tools such as Azure Monitor and Prometheus/Grafana.\n\nDiginsight allows observability of the full application lifecycle, including static methods, injection sequences and the application startup and shutdown sequences where configuration problems and much complexity are often hidden.\n\nDiginsight telemetry is produced by standard ILogger&lt;&gt; and System.Diagnostic activity classes so it integrates (without replacing) other logging systems telemetry. Also, diginsight telemetry is fully integrated with Opentelemetry and the W3C Trace Context Specification so traceids are preserved across process invocations of a distributed system.\nDiginsight telemetry targets all dotnet framework versions starting from netstandard2.0.Samples are available on telemetry.samples repository to demonstrate use of telemetry on .net 4.8 up to [blazor webassembly,].net6 and .net8+ assemblies.  &gt; Diginsight telemetry can capture automatically database queries, outgoing requests as well as missing configuration data. This makes it is an invaluable companion for troubleshooting problems related to missing or invalid data.  &gt; Diginsight Telemetry is fully dynamic: minimal data can be enabled by default, on live environments. Full execution flow observability can be enabled on demand for specific components or specific requests. \nDiginsight Telemetry fully dynamic and automatic nature can be a strong base for automatic problems analysis and resolution.\n\nAdditional Information\nDiginsight telemetry is readable, consistent and efficient:\n\n\nreadable: telemetry is easily readable on local troubleshooting tools, live server consoles and remote analysis tools such as the Azure monitor. The generated application flow is consistent with application code so that problems understanding is much simplified.\nconsistent: the application flow is rendered consistently on local troubleshooting tools, where maximun flow detail is available, and to the remote analysis tools such as the Azure monitor, where metrics and data from past executions can be easily compared.\nefficient: application flow is generated with fully optimized techniques (such as dynamic compilation). Also, the full application flow observability can be enabled dynamically and only on the specific executions that are under analysis. this ensures that diginsight can be leveraged with no pratical impact on application performance.\n\n\nThe image below shows the text based stream associated to to a Web API call. \nThe following image shows the same call on the Azure Monitor Transaction Detail where the call structure is shown as a hierarchy of activities (also called spans) and trace details:  Please, note that the transaction involves two services invocations. The first image reports the detailed log stream for first web application call (PlantsController.GetPlantsAsync). The latter image shows the full transaction detail on Azure Monitor. Both invocations are correlated by the same traceId so, for every transaction, the: the full flow is visible across all services invocations.\nFull observability on live environments can be supported with dynamic logging. Live environments logging level is normally limited to Warning or Information to avoid any cost and performance impact from the telemetry produced by applications. With dynamic logging Log level can be raied to debug or trace for a single call, for example, by means of the Log-Level http headers.\nThe image below shows a call to a live environment where the log level is set to Debug or Trace for 2 categories: \nThe image below shows the live environment App Service console where our call is traced with full datail, while other calls are being processed with limited Log level. \nPerformance information gathered by diginsight can be analyzed in the form of metrics. The following image shows the Azure Monitor Metrics dashboard where method invocations and latencies can be analized in value and frequency:  \nIntelligent sampling, dynamic compilation, automatic truncation and other strategies are used to maximize application efficiency and minimize telemetry costFor these reasons Local analysis and analysis on the remote tools can be supported without compromises on performance and without compromises on cost of telemetry in test and production environments. \n\nHowTo: Use diginsight telemetry with no impact on Application performance an telemetry cost Explores how diginsight telemetry can be used without impact on application performance and telemetry cost.\n\n\n\nLearn more\nThe following articles provide easy steps to integrate diginsight into our code, how to configure telemetry for the local text based strams and how to configure telemetry for the remote analysis tools. Also, details are provided to use its relevant features such as Dynamic configuration and Dynamic Logging.\nExample code used in the articles is also available in the telemetry.samples repository.\n\n\nGetting Started: explores basic steps we can follow to integrate diginsight telemetry\nExample analysis: explores how diginsight can be used to analyze applications and troubleshoot issues.\nObservability Concepts: Explores basic concepts for application observability and Opentelemetry.\nHowTo: configure diginsight telemetry to the local text based streams Explores how we configure diginsight telemetry to the local analysis tools.\nHowTo: use dynamic logging to manage loglevel dynamically, at runtime Explores how we can troubleshoot applications by means of dynamic logging.\nHowTo: use dynamic configuration to manage dynamic options, at runtime Explores how we can troubleshoot applications by means of dynamic configuration.4\nHowTo: configure diginsight telemetry to the remote tools Explores how we configure diginsight telemetry to the remote analysis tools.\nHowTo: Use diginsight telemetry with no impact on Application performance an telemetry cost Explores diginsight telemetry can be used without impact on application performance and telemetry cost.\n\n\nAdvanced topics:\n\n\nHowTo: customize entities rendering on diginsight log streams: Explores how diginsight entities rendereing can be fully customized.\nHowTo: customize metrics sent to the remote tools: Explores how custom metrics sent to the remote tools can be integrated and fully customized with tags.\nHowTo: customize diginsight log streams row content: Explores how diginsight row content can be fully customized.\nHowTo: troubleshoot the startup sequence: Explores how full observability can be enabled on static methods and the startup sequence.\nHowTo: use class aware configurations to support comonent level or class level configurations: Explores how class aware configurations can be used to implement feature flags or configurations that can be enabled with class level granularity.\n\n\nTeam and contributors: &gt;- About: Diginsight is a team of friends (engineers, scientists…) with passion for technology, experimenting ideas and excellence. \n\n\n\nSummary\nDiginsight telemetry is a comprehensive suite of .NET packages designed to provide automatic observability for .NET applications. It enables developers to gain deep insights into the full application lifecycle, from startup to shutdown, including static methods and injection sequences.\nBy leveraging standard ILogger&lt;&gt; and System.Diagnostics activity classes, Diginsight telemetry integrates seamlessly with existing logging systems and supports OpenTelemetry and the W3C Trace Context Specification.\nKey features of Diginsight telemetry include: - Automatic Observability: Capture detailed telemetry data without manual instrumentation. - Full Lifecycle Coverage: Monitor application behavior from startup to shutdown. - Seamless Integration: Works with existing logging systems and supports OpenTelemetry. - Dynamic Configuration: Enable full observability on-demand for specific components or requests. - Performance Optimization: Uses intelligent sampling, dynamic compilation, and other strategies to minimize performance impact and telemetry cost.\nWith Diginsight telemetry, you can troubleshoot issues more effectively, understand application behavior, and ensure optimal performance in both test and production environments.\n\n\nSamples\nYou can start using diginsight telemetry by running the samples on the telemetry.samples repository.\nArticle HOWTO - Use Diginsight Samples: explores how we can use diginsight samples to test and understand integration of Diginsight telemetry in our own projects.\n\n\n\nalt text\n\n\n\n\nBuild and Test\nYou can easily test Diginsight integration with OpenTelemetry by means of the EasySampleBlazorv2 project: - Clone diginsight repository - Open and build solution Diginsight.sln. - build the solution\n\n\n\nContribute\nContribute to the repository with your pull requests.\n\nASP.NET Core\nVisual Studio Code\n\n\n\nLicense\nSee the LICENSE file for license rights and limitations (MIT).\n\n\n\n\n Back to top"
  },
  {
    "objectID": "src/LICENSE.html",
    "href": "src/LICENSE.html",
    "title": "<i class=\"bi bi-lightbulb-fill\" style=\"vertical-align: middle; margin-left: 0px;margin-right: 15px;\"></i> telemetry",
    "section": "",
    "text": "Copyright (c) 2011-2017 GitHub Inc.\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n Back to top"
  },
  {
    "objectID": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html",
    "href": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html",
    "title": "Example Analysis with Diginsight",
    "section": "",
    "text": "Troubleshooting with diginsight is easy and, for any application, it happens in similar ways.",
    "crumbs": [
      "Home",
      "Example Aanalysis"
    ]
  },
  {
    "objectID": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#step-01-reproduce-the-problem-and-analyze-the-detail-flow",
    "href": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#step-01-reproduce-the-problem-and-analyze-the-detail-flow",
    "title": "Example Analysis with Diginsight",
    "section": "STEP 01: reproduce the problem and analyze the detail flow",
    "text": "STEP 01: reproduce the problem and analyze the detail flow\nThe following image shows a diginsight application flow on a text based stream for PlantsController.GetPlantsAsync method. The flow can be easily obtained from developer machine log file, or from application live console such as Azure app streaming log or a Kubernetes console log: \nStarting from its traceid (0f83d3a1e2e834f4b8dab3f3f0f5bc12), the same flow can be found as an Azure Monitor Application transaction: \nFrom the image we can observe that internal component calls are shown into the transaction flow and not just interactions across different components. Also, note that the transaction flow structure is consistent with the transaction flow rendered on the live console log, where more detail is available. Also, note that the transaction flow structure is consistent with the application code as class names, method names, and variable names are obtained automatically.\nLatencies for the same function can be analyzed in a chart with the span_duration metric, filtered on DataAnalyticsReportsController.GetDevices method. \nIn facts, the span_duration metric allows analyzing latencies of any method within code.\nAlso, we’ll see that the developer can easily add other metrics and metric tags to split and compare values in different conditions (eg. by site properties, user properties etc)..",
    "crumbs": [
      "Home",
      "Example Aanalysis"
    ]
  },
  {
    "objectID": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#build-and-test",
    "href": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#build-and-test",
    "title": "Example Analysis with Diginsight",
    "section": "Build and Test",
    "text": "Build and Test\nClone the repository, open and build solution Common.Diagnostics.sln. run EasySample and open the log file in your *** folder.",
    "crumbs": [
      "Home",
      "Example Aanalysis"
    ]
  },
  {
    "objectID": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#contribute",
    "href": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#contribute",
    "title": "Example Analysis with Diginsight",
    "section": "Contribute",
    "text": "Contribute\nContribute to the repository with your pull requests.\n\nASP.NET Core\nVisual Studio Code",
    "crumbs": [
      "Home",
      "Example Aanalysis"
    ]
  },
  {
    "objectID": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#license",
    "href": "src/docs/00.1 Example Analysis/00.01 - How to troubleshoot issues.html#license",
    "title": "Example Analysis with Diginsight",
    "section": "License",
    "text": "License\nSee the LICENSE file for license rights and limitations (MIT).",
    "crumbs": [
      "Home",
      "Example Aanalysis"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html",
    "href": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html",
    "title": "HowTo: Configure diginsight telemetry to the local text based streams",
    "section": "",
    "text": "You can ottain a console log or file log with diginsight by means of the steps shown below.\nThe code snippets are available as working samples within the telemetry.samples repository. Article HOWTO - Use Diginsight Samples.md: explores how we can use diginsight samples to test and understand integration of Diginsight telemetry in our own projects.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the local text based streams"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-01---add-a-package-reference-to-the-package-diginsight.diagnostics-or-diginsight.diagnostics.log4net",
    "href": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-01---add-a-package-reference-to-the-package-diginsight.diagnostics-or-diginsight.diagnostics.log4net",
    "title": "HowTo: Configure diginsight telemetry to the local text based streams",
    "section": "STEP 01 - Add a package reference to the package Diginsight.Diagnostics or Diginsight.Diagnostics.Log4Net",
    "text": "STEP 01 - Add a package reference to the package Diginsight.Diagnostics or Diginsight.Diagnostics.Log4Net\nIn the first step you can just add a diginsight reference to your code:  reference to Diginsight.Diagnostics is needed for the Console log and Diginsight.Diagnostics.Log4Net is required to enable Log4Net File log.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the local text based streams"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-02---configure-logging-within-the-startup-sequence",
    "href": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-02---configure-logging-within-the-startup-sequence",
    "title": "HowTo: Configure diginsight telemetry to the local text based streams",
    "section": "STEP 02 - Configure logging within the Startup sequence",
    "text": "STEP 02 - Configure logging within the Startup sequence\nIn the second step you can configure the startup sequence to enable diginsight log:\npublic static void Main(string[] args)\n{\n    var builder = WebApplication.CreateBuilder(args);\n    var services = builder.Services;\n    var configuration = builder.Configuration;\n    var environment = builder.Environment;\n\n    // Add logging providers\n    services.AddObservability(configuration, environment);\n\n    services.AddControllers();\n    services.AddEndpointsApiExplorer();\n    services.AddSwaggerGen();\n\n    // Use diginsight service provider \n    // this enables telemetry initialization at service provider creation\n    builder.Host.UseDiginsightServiceProvider(true);\n    WebApplication app = builder.Build();\n\n    if (app.Environment.IsDevelopment())\n    {\n        app.UseSwagger();\n        app.UseSwaggerUI();\n    }\n\n    app.UseHttpsRedirection();\n\n    app.UseAuthorization();\n\n    app.MapControllers();\n\n    app.Run();\n}\nin the code above: - AddObservability() is used to add log to the application Console and a log4net file log. - UseDiginsightServiceProvider() is used to activate diginsight during the service provider build() process.\nPlease note that AddObservability() is implemented as an extension method that calls AddLogging() with: - AddDiginsightConsole(): this methods configures the Console log provider with some formatting options \n\nAddDiginsightLog4Net(): this methods configures a rolling File log on the user profile folder. \n\n\nThe code above loads telemety based on the Diginsight:Activities configuration section that includes the enabled ActivitySources and their LogBehavior. \n\"Diginsight\": {\n    \"Activities\": {\n        \"LogBehavior\": \"Show\",\n        \"MeterName\": \"SampleWebAPI\",\n        \"ActivitySources\": {\n        \"Microsoft.AspNetCore\": true,\n        \"System.Net.Http\": true,\n        \"Experimental.*\": false,\n        \"Diginsight.*\": true,\n        \"SampleWebAPI\": true\n        },\n        \"LoggedActivityNames\": {\n        \"System.Net.Http|System.Net.Http.HttpRequestOut\": \"Hide\",\n        \"Microsoft.AspNetCore.Hosting.HttpRequestIn\": \"Hide\"\n        }\n    }\n}\nActivities LogBehavior can be set to: - Show: the activity is logged. - Hide: the activity is not logged. - Truncate: the activity and all inner activities called within its scope are not logged.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the local text based streams"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-03---add-telemetry-to-code-with-startmethodactivity-and-ilogger-statements",
    "href": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-03---add-telemetry-to-code-with-startmethodactivity-and-ilogger-statements",
    "title": "HowTo: Configure diginsight telemetry to the local text based streams",
    "section": "STEP 03 - Add telemetry to code with StartMethodActivity() and ILogger Statements",
    "text": "STEP 03 - Add telemetry to code with StartMethodActivity() and ILogger Statements\nWe are now ready to add instrumentation to the code and make the application flow observable.\nThe snippet below shows how to add telemetry to the GetWeatherForecast() method of the WeatherForecastController class:\n[HttpGet(Name = \"GetWeatherForecast\")]\npublic IEnumerable&lt;WeatherForecast&gt; Get()\n{\n    // send method START and END events with Observability.ActivitySource\n    using var activity = Observability.ActivitySource.StartMethodActivity(logger);\n\n    var randomTemperature = Random.Shared.Next(-20, 55);\n    // add to logger.LogDebug to send a log event\n    logger.LogDebug(\"randomTemperature: {randomTemperature}\", randomTemperature);\n\n    var res = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast\n    {\n        Date = DateOnly.FromDateTime(DateTime.Now.AddDays(index)),\n        TemperatureC = randomTemperature,\n        Summary = Summaries[Random.Shared.Next(Summaries.Length)]\n    }).ToArray();\n\n    activity?.SetOutput(res);\n    return res;\n}\nin the snippet above: - using var activity = Observability.ActivitySource.StartMethodActivity(logger); is added to provide observability of method start and end - logger.LogDebug(\"randomTemperature: {randomTemperature}\", randomTemperature); is usd to log the randomTemperature value, during the method execution. - activity.SetOutput(result); is used to add the method result to the method END event.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the local text based streams"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-04---run-your-code-and-look-at-the-resulting-application-flow",
    "href": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-04---run-your-code-and-look-at-the-resulting-application-flow",
    "title": "HowTo: Configure diginsight telemetry to the local text based streams",
    "section": "STEP 04 - run your code and look at the resulting application flow",
    "text": "STEP 04 - run your code and look at the resulting application flow\nThe image below shows the application flow generated by DoSomeWork method The image belpw shows the sample method execution, where - method start and end are logged with the Method name, - randomTemperature is logged as a standard variable value and - the method result is logged within the method END raw.\n\n\n\nalt text",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the local text based streams"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-03-full---add-telemetry-for-the-startup-sequence",
    "href": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-03-full---add-telemetry-for-the-startup-sequence",
    "title": "HowTo: Configure diginsight telemetry to the local text based streams",
    "section": "STEP 03 (Full) - Add telemetry for the startup sequence",
    "text": "STEP 03 (Full) - Add telemetry for the startup sequence\nThe S01_01_SampleWebAPIWithStartupSequence sample shows an example WebApi where telemetry is enabled also for the full startup sequence.\nAn ObservabilityManager is created with a LoggerFactory to record telemetry events until the ASP.NET Core Service Provider creation. When the Service Provider is created, the recorded startup telemetry is sent to the configured registered providers (eg. Console, Log4Net). In case of Exceptions during the startup sequence, telemetry is flushed to the Console/log4net by means of an emergency service provider, managed by the Observability manager.\npublic static void Main(string[] args)\n{\n    // this enables sending telemetry for the startup sequence\n    // telemetry is recorded until ServiceProvider creation\n    // after that, recorded telemetry is sent to the configured registered providers\n    // (eg. AzureMonitor, Console, Log4Net) \n    using var observabilityManager = new ObservabilityManager();\n    ILogger logger = observabilityManager.LoggerFactory.CreateLogger(typeof(Program));\n    Observability.LoggerFactory = observabilityManager.LoggerFactory;\n\n    WebApplication app;\n    using (var activity = Observability.ActivitySource.StartMethodActivity(logger, new { args }))\n    {\n        var builder = WebApplication.CreateBuilder(args);\n        var services = builder.Services;\n        var configuration = builder.Configuration;\n        var environment = builder.Environment;\n\n        // Add logging and opentelemetry providers\n        services.AddObservability(configuration, environment, out IOpenTelemetryOptions openTelemetryOptions);\n\n        // registers recorded telemetry for flush after ServiceProvider creation\n        observabilityManager.AttachTo(services);\n\n        services.AddControllers();\n        services.AddEndpointsApiExplorer();\n        services.AddSwaggerGen();\n\n        // use diginsight service provider \n        // this enables telemetry initialization at service provider creation\n        builder.Host.UseDiginsightServiceProvider(true);\n        app = builder.Build();\n\n        if (app.Environment.IsDevelopment())\n        {\n            app.UseSwagger();\n            app.UseSwaggerUI();\n        }\n\n        app.UseHttpsRedirection();\n\n        app.UseAuthorization();\n\n        app.MapControllers();\n    }\n\n    app.Run();\n}",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the local text based streams"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-04-full---run-your-code-and-look-at-the-resulting-application-flow",
    "href": "src/docs/01. Concepts/01.00 - Configure diginsight telemetry to the local text based streams.html#step-04-full---run-your-code-and-look-at-the-resulting-application-flow",
    "title": "HowTo: Configure diginsight telemetry to the local text based streams",
    "section": "STEP 04 (Full) - run your code and look at the resulting application flow",
    "text": "STEP 04 (Full) - run your code and look at the resulting application flow\nThe image below shows the application flow generated by the startup sequence. In particular, Program.Main() method is logged with registration details of AddObservability() method.,",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Configure diginsight telemetry to the local text based streams"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/11.00 - HowTo - Use Dynamic-Logging to manage loglevel dinamically at runtime.html",
    "href": "src/docs/01. Concepts/11.00 - HowTo - Use Dynamic-Logging to manage loglevel dinamically at runtime.html",
    "title": "HowTo: Use dynamic logging to manage loglevel dinamically, at runtime",
    "section": "",
    "text": "diginsight telemetry supports dynamic logging to hot switch the minimum log level (e.g. from Information or Warning to Debug or Trace levels) of any log category.\nTo minimize telemetry cost and performance impact, telemetry sent to the remote tools is normally limited to LogLevels Critical, Warning or Information.\nThe snippet below shows a tipical Logging section configuration for a production environment:\nUsing Diginsight telemetry on a Web API or Web Application, the log level for any category can be overridden at runtime, for a single call, by means of the Log-Level http request headers.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use dynamic logging to manage loglevel dinamically, at runtime"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/11.00 - HowTo - Use Dynamic-Logging to manage loglevel dinamically at runtime.html#additional-information",
    "href": "src/docs/01. Concepts/11.00 - HowTo - Use Dynamic-Logging to manage loglevel dinamically at runtime.html#additional-information",
    "title": "HowTo: Use dynamic logging to manage loglevel dinamically, at runtime",
    "section": "Additional Information",
    "text": "Additional Information\nThe image below shows the logstream for a web API where only Critical, Warning and Information and levels are enabled.\nWhile the application is running the streaming log shows only limited (or no) information about the application execution flow.\n\n\n\nalt text\n\n\nIn case we need to troubleshoot a specific application call flow, it is possible to reporduce the call specifying different log levels for some categories: \nThis will result in the full application flow being shown for the specific call: \n\nthis way, every call application flow can be easily isolated and analized on a live server, that is processing other calls at the same time.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use dynamic logging to manage loglevel dinamically, at runtime"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/11.00 - HowTo - Use Dynamic-Logging to manage loglevel dinamically at runtime.html#howto-enable-dynamic-loggging",
    "href": "src/docs/01. Concepts/11.00 - HowTo - Use Dynamic-Logging to manage loglevel dinamically at runtime.html#howto-enable-dynamic-loggging",
    "title": "HowTo: Use dynamic logging to manage loglevel dinamically, at runtime",
    "section": "HowTo Enable Dynamic Loggging",
    "text": "HowTo Enable Dynamic Loggging\nDynamic logging can be enabled adding the following stagement: services.AddDynamicLogLevel&lt;DefaultDynamicLogLevelInjector&gt;(); to the ConfigureServices methods, in the application startup sequence.\nThe image below shows that statement into startup sequence of the S01_00_SampleWebAPI project, within diginsight telemetry.samples repository:",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use dynamic logging to manage loglevel dinamically, at runtime"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html",
    "href": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html",
    "title": "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost",
    "section": "",
    "text": "Diginsight brings application behavior observability to the next step. In particular The full application flow is made available to local text based streams such as the Console log or the Streaming log. The same information can be made available to remote tools for troubleshooting or performance analysis such as Azure Monitor or Grafana.\nThe following example shows the execution flow of a Web API call, .\nThe call shows a REST http call landing on PlantsController.GetPlantsAsync() method in turn invoking a api/Users/getUsers endpoint on an external endpoint. than calling a PlantsController.GetPlantsImplAsync() method in a loop. \nThe following image shows the same call log4net file log with full detail of the call flow.: \nIn the following paragraphs we’ll understand how this observability can be obtained without impact on the application performance.\nAlso, you will soon learn that diginsight can be of great help with identifying and reducing high latency flows and redundant flows within the application execution paths.\nSo diginsight can greatly contribute to application performance optimization more than provide a limitation to it. &gt; &gt;With article: GETTING STARTED We explore how we can make our application flow fully observable.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#introduction",
    "href": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#introduction",
    "title": "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost",
    "section": "",
    "text": "Diginsight brings application behavior observability to the next step. In particular The full application flow is made available to local text based streams such as the Console log or the Streaming log. The same information can be made available to remote tools for troubleshooting or performance analysis such as Azure Monitor or Grafana.\nThe following example shows the execution flow of a Web API call, .\nThe call shows a REST http call landing on PlantsController.GetPlantsAsync() method in turn invoking a api/Users/getUsers endpoint on an external endpoint. than calling a PlantsController.GetPlantsImplAsync() method in a loop. \nThe following image shows the same call log4net file log with full detail of the call flow.: \nIn the following paragraphs we’ll understand how this observability can be obtained without impact on the application performance.\nAlso, you will soon learn that diginsight can be of great help with identifying and reducing high latency flows and redundant flows within the application execution paths.\nSo diginsight can greatly contribute to application performance optimization more than provide a limitation to it. &gt; &gt;With article: GETTING STARTED We explore how we can make our application flow fully observable.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#performance-considerations",
    "href": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#performance-considerations",
    "title": "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost",
    "section": "Performance considerations",
    "text": "Performance considerations\nThe following image defines key drivers used by diginsights to avoid performence impacts: \n\nDriver n°1: No heap pressure when disabled\nThe following code snippet shows a method instrumented by means of diginsight System.Diagnostics activities:\npublic async Task&lt;IEnumerable&lt;Plant&gt;&gt; GetPlantByIdCachedAsync(Guid id)\n{\n    using var activity = Program.ActivitySource.StartMethodActivity(logger, () =&gt; new { id });\n\n    // Method implementation\n    // ...\n\n    activity?.SetOutput(plants);\n    return plants;\n}\nWhen disabling an activity source, the activities for it are not created and StartMethodActivity returns null. Also, if delegate notation is used to provide the StartMethodActivity payload, in case logging or payload rendering are disabled, the delegate is not used and the payload class is not allocated into the heap.\n\n\n\nalt text\n\n\nIn such conditions, diginsight activities are not at all generated or used and do not provide any performance impact to the overall application.\n\n\nDriver n°2: No processing for disabled logs\nNeedless to say, when log is disabled, method payloads are not processed at all and no strings are generated for method spans start and completion.\nAlso intermediate logger.LogXxxx() statements, when using structured logging notation do not involve any string composition.\npublic async Task&lt;IEnumerable&lt;Plant&gt;&gt; GetPlantByIdCachedAsync(Guid id)\n{\n    using var activity = Program.ActivitySource.StartMethodActivity(logger, () =&gt; new { id });\n\n    // Method implementation\n    // ...\n    logger.LogInformation(\"Plant '{Name}' ({Id}) accessed\", plant.Name, plant.Id)\n\n    activity?.SetOutput(plants);\n    return plants;\n}\n\n\nDriver n°3: Intelligent sampling can be used to limit data sent to the remote tools\nDiginsight supports intelligent sampling by means of OpenTelemetry sampling support.\nWith OpenTelemetry, a full execution within a component is identified as a trace. The image below shows an example trace where all rows share the same trace_id.\n\n\n\nalt text\n\n\nWhen an exevution flow is selected for sending to the remote tools, all the rows within the flow are sent. When an exevution flow is omitted, all the rows within the flow are omitted. This way. consistency and readability of data sent to the remote tools is ensured. Also, data sent to the remote tools can be limited in size, as well as its cost and performance impact.\nThe image below shows an end to end transation detail sent to the Azure Monitor: All the transaction flow is sent, regardless of the sampling ratio configured for the application. \nThe configuration section below, specifies a \"TracingSamplingRatio\": 0.1. In such case, only one execution flow should be sent to the remote tools, out of 10.\n  \"OpenTelemetry\": {\n    \"EnableMetrics\": true,\n    \"EnableTraces\": true,\n    \"TracingSamplingRatio\": 0.1,\n    \"ActivitySources\": [\n      \"Azure.Cosmos.Operation\",\n      \"Azure.Storage.Blobs.BlobBaseClient\",\n      \"Microsoft.AspNetCore\",\n      \"Diginsight.*\",\n      \"ABB.*\"\n    ],\n    \"ExcludedHttpHosts\": [\n      \"login.microsoftonline.com\",\n      \".documents.azure.com\",\n      \".applicationinsights.azure.com\",\n      \".monitor.azure.com\",\n      \".b2clogin.com\"\n    ],\n    \"DurationMetricTags\": [\n      \"widget_template\",\n      \"site_name\"\n    ]\n  },\nOn a production environment you may choose to keep a default Sampling Ratio from 0.1 to 0.4 to ensure minimal telemetry volumes and cost still allowing systems behaviours analysis (eg. average Latencies, metrics dashboards etc). Dynamic Logging and Dynamic configuration can be used to act on this parameter, for limited intervals or for specific execution flows, without need of application restart. This will ensure Full troubleshooting support.\n\nit is perfectly feasible to operate on a production environment keeping telemetry cost below a threshold (eg. in our case we work at about 5%) of the overall infrastructure cost, still ensuring full observability for troubleshooting of production issues.\n\n\n\nDriver n°4: Traces sent to the remote tools are higly configurable\nData sent to the remote tools can be configured by means of the OpenTelemetry section:\n\"OpenTelemetry\": {\n    \"EnableMetrics\": true,\n    \"EnableTraces\": true,\n    \"TracingSamplingRatio\": 0.1,\n    \"ActivitySources\": [\n        \"Azure.Cosmos.Operation\",\n        \"Azure.Storage.Blobs.BlobBaseClient\",\n        \"Microsoft.AspNetCore\",\n        \"Diginsight.*\",\n        \"ABB.*\"\n    ]\n},\n\nEnableMetrics (def. true): specifies whether metrics are sent to the remote tools\nEnableTraces (def. true): specifies whether traces are sent to the remote tools\nTracingSamplingRatio (def. 1): specifies the sampling ratio for data sent to the remote tools.\nActivitySources: identifies the activity sources enabled for sending data to the remote tools.\n\n\n\nDriver n°5: Metrics sent to the remote tools are higly configurable\nWith OpenTelemetry, every execution flow (trace) can be composed of multiple spans. Diginsight gathers automatically few simple metrics such as the diginsight.span_duration that describes every single method latency.\nThe local troubleshooting tools show the diginsight.span_duration metric at any span completion row: \nDiginsights can be configured to send the span_duration metric to the remote tools. The following charts show diginsight span_duration metric for a few methods on an Azure Monitor dashboard:\n\n\n\n\n\n\n\nspan_duration kql query\nspan_duration chart\n\n\n\n\n\n\n\n\n\nRecordSpanDurations class aware option can be used to specify specific methods for which span_duration metric should be sent to the remote tools.\nIn particular, the RecordSpanDurations flag can be set at namespace or class granularity level. As an example, the configuration snippet below specifies that RecordSpanDurations flag is enabled only for Microsoft and Diginsight namespaces:\n\"Diginsight\": {\n    \"Activities\": {\n        \"RecordSpanDurations\": false,\n        \"RecordSpanDurations@Microsoft.*\": true,\n        \"RecordSpanDurations@Diginsight.*\": true\n    }\n}\n\n\nDriver n°6: Use Request level dynamic Logging to hot switch log levels on local troubleshooting tools\nWith diginsight, you can safely send sampled telemetry to the remote troubleshooting tools. This allows capturing application behaviors and trends. Also, logging to the local troubleshooting tools can normally be kept at Warning or Information level. This way, only limited information is sent to the remote tools and also, limited information is written to the local troubleshooting tools.\nThe snippet below shows a normal configuration for a runtime environment where only Information or warning level is enabled for few logging categories:\n\"Logging\": {\n  \"LogLevel\": {\n    \"Default\": \"Warning\",\n    \"Microsoft\": \"Warning\",\n    \"Microsoft.Hosting.Lifetime\": \"Information\",\n    \"Diginsight.SmartCache.Externalization.ServiceBus\": \"Warning\",\n    \"*.BodyLoggingHandler\": \"Warning\"\n  }\n},\nThe image below shows an application streaming log where only limited information is written about exceptional conditions: \nIn case specific troubleshooting is needed for an application behaviour you can use dynamic logging to elevate application logging level for any logging category.\nThe image shows an example call to the server where LogLevel is elevated to Trace: \nThis will result in the full application flow being shown for the specific call: \nThis way, a single call application flow can be easily isolated and analized on a live server, that is processing other calls at the same time.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#build-and-test",
    "href": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#build-and-test",
    "title": "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost",
    "section": "Build and Test",
    "text": "Build and Test\nClone the repository, open and build solution Diginsight.sln. run EasySample and open the log file in your *** folder.",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#contribute",
    "href": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#contribute",
    "title": "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost",
    "section": "Contribute",
    "text": "Contribute\nContribute to the repository with your pull requests.\n\nASP.NET Core\nVisual Studio Code",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost"
    ]
  },
  {
    "objectID": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#license",
    "href": "src/docs/01. Concepts/20.00 - HowTo Use diginsight telemetry with no impact on Application performance an telemetry cost.html#license",
    "title": "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost",
    "section": "License",
    "text": "License\nSee the LICENSE file for license rights and limitations (MIT).",
    "crumbs": [
      "Home",
      "Concepts",
      "HowTo: Use diginsight telemetry with no impact on Application performance and telemetry cost"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/14.00 - Customize metrics sent to the remote tools.html",
    "href": "src/docs/02. Advanced/14.00 - Customize metrics sent to the remote tools.html",
    "title": "Customize metrics",
    "section": "",
    "text": "article in progress",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Customize metrics"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/14.00 - Customize metrics sent to the remote tools.html#customize-metrics-sent-to-the-remote-tools",
    "href": "src/docs/02. Advanced/14.00 - Customize metrics sent to the remote tools.html#customize-metrics-sent-to-the-remote-tools",
    "title": "Customize metrics",
    "section": "",
    "text": "article in progress",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Customize metrics"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html",
    "title": "Throubleshoot the startup sequence",
    "section": "",
    "text": "The most tricky or the most critical bugs are often hidden in the application startup sequence or application static methods. As an example, startup configurations such as connection string or resources access keys may be wrong or missing. Also, static contructors within the application or its dependencies may hide tricky bugs that are difficult to troubleshoot.\nThose places are usually difficult to troubleshoot as telemetry may be not active when they are executed.\nDiginsight telemetry enables full observability also for these parts by means of the DeferredLoggerFactory that provides recording the application flow until the telemetry infrastructure is set up.\nUpon setup completion, telemetry recording is flushed right before the standard telemetry flow gathering so that any configuration problem or error can be made visible.\nThe code snippets below are available as working samples within the telemetry_samples repository.\nIn particular the steps shown below explain how the startup sequence can be made observable on the SampleWebApi within the telemetry_samples repository.\n\n\n\nalt text",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Throubleshoot the startup sequence"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#introduction",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#introduction",
    "title": "Throubleshoot the startup sequence",
    "section": "",
    "text": "The most tricky or the most critical bugs are often hidden in the application startup sequence or application static methods. As an example, startup configurations such as connection string or resources access keys may be wrong or missing. Also, static contructors within the application or its dependencies may hide tricky bugs that are difficult to troubleshoot.\nThose places are usually difficult to troubleshoot as telemetry may be not active when they are executed.\nDiginsight telemetry enables full observability also for these parts by means of the DeferredLoggerFactory that provides recording the application flow until the telemetry infrastructure is set up.\nUpon setup completion, telemetry recording is flushed right before the standard telemetry flow gathering so that any configuration problem or error can be made visible.\nThe code snippets below are available as working samples within the telemetry_samples repository.\nIn particular the steps shown below explain how the startup sequence can be made observable on the SampleWebApi within the telemetry_samples repository.\n\n\n\nalt text",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Throubleshoot the startup sequence"
    ]
  },
  {
    "objectID": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#how-to-make-the-startup-sequence-observable",
    "href": "src/docs/02. Advanced/16.00 - Troubleshoot the startup sequence.html#how-to-make-the-startup-sequence-observable",
    "title": "Throubleshoot the startup sequence",
    "section": "How to make the startup sequence observable",
    "text": "How to make the startup sequence observable\nThe following code snippet shows the startup method of the SampleWebApi project:\npublic static IDeferredLoggerFactory DeferredLoggerFactory;\ninternal static readonly ActivitySource ActivitySource = new(typeof(Program).Namespace ?? typeof(Program).Name!);\n\npublic static void Main(string[] args)\n{\n    DiginsightActivitiesOptions activitiesOptions = new() { LogActivities = true };\n    DeferredLoggerFactory = new DeferredLoggerFactory(activitiesOptions: activitiesOptions);\n    var logger = DeferredLoggerFactory.CreateLogger&lt;Program&gt;();\n\n    ActivitySource activitySource = new(typeof(Program).Namespace!);\n    DeferredLoggerFactory.ActivitySources.Add(activitySource);\n    DiginsightDefaults.ActivitySource = activitySource;\n\n    IWebHost host;\n    using (var activity = DiginsightDefaults.ActivitySource.StartMethodActivity(logger, new { args }))\n    {\n        host = WebHost.CreateDefaultBuilder(args)\n            .ConfigureAppConfiguration2()\n            .UseStartup&lt;Startup&gt;()\n            .ConfigureServices(services =&gt;\n            {\n                var logger = DeferredLoggerFactory.CreateLogger&lt;Startup&gt;();\n                using var innerActivity = ActivitySource.StartRichActivity(logger, \"ConfigureServicesCallback\", new { services });\n\n                services.TryAddSingleton(DeferredLoggerFactory);\n            })\n            .UseDiginsightServiceProvider()\n            .Build();\n\n        logger.LogDebug(\"Host built\");\n    }\n\n    host.Run();\n}\na IDeferredLoggerFactory and an ILogger instance are created at startup, immediatly after application start:\nDiginsightActivitiesOptions activitiesOptions = new() { LogActivities = true };\nDeferredLoggerFactory = new DeferredLoggerFactory(activitiesOptions: activitiesOptions);\nvar logger = DeferredLoggerFactory.CreateLogger&lt;Program&gt;();\nDotnet logging is not configured or activated already, however logger instance is recording all activities START, END and all explicit logging operations.\nPlease, note that the logger factory is passed the activitySources that are used so that it can register as a listener to them.\nDeferredLoggerFactory.ActivitySources.Add(activitySource);\nthe Startup ConfigureServices method registers observability with AddObservability() method. Also, it registers recorded telemetry flush with FlushOnCreateServiceProvider().\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddHttpContextAccessor();\n    services.AddObservability(configuration);\n    services.AddDynamicLogLevel&lt;DefaultDynamicLogLevelInjector&gt;();\n    services.FlushOnCreateServiceProvider(deferredLoggerFactory);\nAfter services configuration, right before the host build, the telemetry and logging will be configured and activated. The UseDiginsightServiceProvider() call will run the registered telemetry Flush() and all the deferred logs will be flushed to the telemetry targets.\n\n\n\nalt text\n\n\nApi startup will then show all logs recorded during startup:\n\n\n\nalt text",
    "crumbs": [
      "Home",
      "Advanced Articles",
      "Throubleshoot the startup sequence"
    ]
  },
  {
    "objectID": "src/docs/05. About/about.html",
    "href": "src/docs/05. About/about.html",
    "title": "Team",
    "section": "",
    "text": "Diginsight is a free opensource project.",
    "crumbs": [
      "Home",
      "About",
      "Team"
    ]
  },
  {
    "objectID": "src/docs/05. About/about.html#project-members",
    "href": "src/docs/05. About/about.html#project-members",
    "title": "Team",
    "section": "Project members",
    "text": "Project members\n\n\n\n\n\n\n\n\n\nFilippo Mineo\nMilan, Italy\n\n\n\nAlessandro Avila\nMilan, Italy\n\n\n\nDario Airoldi\nMilan, Italy",
    "crumbs": [
      "Home",
      "About",
      "Team"
    ]
  },
  {
    "objectID": "src/docs/05. About/about.html#other-contributors",
    "href": "src/docs/05. About/about.html#other-contributors",
    "title": "Team",
    "section": "Other Contributors",
    "text": "Other Contributors\nChayashree Gollahalli | Bhangalore, India Carlo Bollini | Milan, Italy Metushi Margil | Milan, Italy Maurizio Iacovella | Milan, Italy Matteo Delli Rocioli | Milan, Italy Raffaele Fanizzi | Milan, Italy",
    "crumbs": [
      "Home",
      "About",
      "Team"
    ]
  }
]